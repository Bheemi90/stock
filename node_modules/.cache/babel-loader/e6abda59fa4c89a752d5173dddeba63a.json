{"ast":null,"code":"function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport max from 'lodash/max';\nimport min from 'lodash/min';\nimport isNil from 'lodash/isNil';\nimport isFunction from 'lodash/isFunction';\nimport isString from 'lodash/isString';\nimport get from 'lodash/get';\nimport flatMap from 'lodash/flatMap';\nimport isNan from 'lodash/isNaN';\nimport upperFirst from 'lodash/upperFirst';\nimport isEqual from 'lodash/isEqual';\nimport sortBy from 'lodash/sortBy';\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport { ErrorBar } from '../cartesian/ErrorBar';\nimport { findEntryInArray, getPercentValue, isNumber, isNumOrStr, mathSign, uniqueId } from './DataUtils';\nimport { filterProps, findAllByType, getDisplayName } from './ReactUtils'; // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nimport { getLegendProps } from './getLegendProps'; // Exported for backwards compatibility\n\nexport { getLegendProps };\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNil(obj) || isNil(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n\n  if (isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n}\n/**\n * Get domain of data by key.\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n\n  if (type === 'number') {\n    // @ts-expect-error parseFloat type only accepts strings\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [min(domain), max(domain)] : [Infinity, -Infinity];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !isNil(entry);\n  }) : flattenData; // Supports x-axis of Date type\n\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0; // if there are 1 or less ticks ticks then the active tick is at index 0\n\n  if (len <= 1) {\n    return 0;\n  }\n\n  if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n    var range = axis.range; // ticks are distributed in a circle\n\n    for (var i = 0; i < len; i++) {\n      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n      var cur = unsortedTicks[i].coordinate;\n      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n      var sameDirectionCoord = void 0;\n\n      if (mathSign(cur - before) !== mathSign(after - cur)) {\n        var diffInterval = [];\n\n        if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n          sameDirectionCoord = after;\n          var curInRange = cur + range[1] - range[0];\n          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n        } else {\n          sameDirectionCoord = before;\n          var afterInRange = after + range[1] - range[0];\n          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n        }\n\n        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      } else {\n        var minValue = Math.min(before, after);\n        var maxValue = Math.max(before, after);\n\n        if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    // ticks are distributed in a single direction\n    for (var _i = 0; _i < len; _i++) {\n      if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n        index = ticks[_i].index;\n        break;\n      }\n    }\n  }\n\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _item$type;\n\n  var _ref = item,\n      displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n\n  var defaultedProps = (_item$type = item.type) !== null && _item$type !== void 0 && _item$type.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n  var stroke = defaultedProps.stroke,\n      fill = defaultedProps.fill;\n  var result;\n\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n\n    default:\n      result = fill;\n      break;\n  }\n\n  return result;\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref2) {\n  var globalSize = _ref2.barSize,\n      totalSize = _ref2.totalSize,\n      _ref2$stackGroups = _ref2.stackGroups,\n      stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;\n\n  if (!stackGroups) {\n    return {};\n  }\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n\n      if (barItems && barItems.length) {\n        var barItemDefaultProps = barItems[0].type.defaultProps;\n        var barItemProps = barItemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, barItemDefaultProps), barItems[0].props) : barItems[0].props;\n        var selfSize = barItemProps.barSize;\n        var cateId = barItemProps[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        var barSize = isNil(selfSize) ? globalSize : selfSize;\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: isNil(barSize) ? undefined : getPercentValue(barSize, totalSize, 0)\n        });\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Calculate the size of each bar and offset between start of band and the bar\n *\n * @param  {number} bandSize is the size of area where bars can render\n * @param  {number | string} barGap is the gap size, as a percentage of `bandSize`.\n *                                  Can be defined as number or percent string\n * @param  {number | string} barCategoryGap is the gap size, as a percentage of `bandSize`.\n *                                  Can be defined as number or percent string\n * @param  {Array<object>} sizeList Sizes of all groups\n * @param  {number} maxBarSize The maximum size of each bar\n * @return {Array<object>} The size and offset of each bar\n */\n\nexport var getBarPosition = function getBarPosition(_ref3) {\n  var barGap = _ref3.barGap,\n      barCategoryGap = _ref3.barCategoryGap,\n      bandSize = _ref3.bandSize,\n      _ref3$sizeList = _ref3.sizeList,\n      sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList,\n      maxBarSize = _ref3.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result;\n  var initialValue = []; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len; // @ts-expect-error the type check above does not check for type number explicitly\n\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newPosition = {\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          // @ts-expect-error the type check above does not check for type number explicitly\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      };\n      var newRes = [].concat(_toConsumableArray(res), [newPosition]);\n      prev = newRes[newRes.length - 1].position;\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n\n      return newRes;\n    }, initialValue);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n\n      return newRes;\n    }, initialValue);\n  }\n\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, _unused, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n\n  if (legendProps) {\n    var _ref4 = legendBox || {},\n        boxWidth = _ref4.width,\n        boxHeight = _ref4.height;\n\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, offset[align] + (boxWidth || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, offset[verticalAlign] + (boxHeight || 0)));\n    }\n  }\n\n  return offset;\n};\n\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n  if (isNil(axisType)) {\n    return true;\n  }\n\n  if (layout === 'horizontal') {\n    return axisType === 'yAxis';\n  }\n\n  if (layout === 'vertical') {\n    return axisType === 'xAxis';\n  }\n\n  if (direction === 'x') {\n    return axisType === 'xAxis';\n  }\n\n  if (direction === 'y') {\n    return axisType === 'yAxis';\n  }\n\n  return true;\n};\n\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n  });\n\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey);\n      if (isNil(entryValue)) return result;\n      var mainValue = Array.isArray(entryValue) ? [min(entryValue), max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n  }).filter(function (entry) {\n    return !isNil(entry);\n  });\n\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {LayoutType} layout The type of layout\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce( // @ts-expect-error if (type === number) means that the domain is numerical type\n    // - but this link is missing in the type definition\n    function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      // @ts-expect-error Date cannot index an object\n      if (!tag[entry[i]]) {\n        // @ts-expect-error Date cannot index an object\n        tag[entry[i]] = true; // @ts-expect-error Date cannot index an object\n\n        result.push(entry[i]);\n      }\n    }\n\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimun value of axis\n * @param {Number} maxValue        The maximun value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, minValue, maxValue, syncWithTicks) {\n  if (syncWithTicks) {\n    return ticks.map(function (entry) {\n      return entry.coordinate;\n    });\n  }\n\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(minValue);\n  }\n\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type,\n      range = axis.range;\n  var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axis.axisType === 'angleAxis' && (range === null || range === void 0 ? void 0 : range.length) >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks set by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    var result = (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n    return result.filter(function (row) {\n      return !isNan(row.coordinate);\n    });\n  } // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} childHandler Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nvar handlerWeakMap = new WeakMap();\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, childHandler) {\n  if (typeof childHandler !== 'function') {\n    return defaultHandler;\n  }\n\n  if (!handlerWeakMap.has(defaultHandler)) {\n    handlerWeakMap.set(defaultHandler, new WeakMap());\n  }\n\n  var childWeakMap = handlerWeakMap.get(defaultHandler);\n\n  if (childWeakMap.has(childHandler)) {\n    return childWeakMap.get(childHandler);\n  }\n\n  var combineHandler = function combineHandler() {\n    defaultHandler.apply(void 0, arguments);\n    childHandler.apply(void 0, arguments);\n  };\n\n  childWeakMap.set(childHandler, combineHandler);\n  return combineHandler;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @param  {Boolean}  hasBar        if it has a bar\n * @return {object}               The scale function and resolved name\n */\n\nexport var parseScale = function parseScale(axis, chartType, hasBar) {\n  var scale = axis.scale,\n      type = axis.type,\n      layout = axis.layout,\n      axisType = axis.axisType;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n\n  if (isString(scale)) {\n    var name = \"scale\".concat(upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n\n  return isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n\n  return null;\n};\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param {Array} value input that will be truncated\n * @param {Array} domain boundaries\n * @returns {Array} tuple of two numbers\n */\n\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n\n  return result;\n};\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n\n    }\n  }\n};\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\n\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n\n    }\n  }\n};\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n  var stack = shapeStack() // @ts-expect-error stack.keys type wants an array of strings, but we provide array of DataKeys\n  .keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone) // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var parentStackGroupsInitialValue = {};\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$type2;\n\n    var defaultedProps = (_item$type2 = item.type) !== null && _item$type2 !== void 0 && _item$type2.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var stackId = defaultedProps.stackId,\n        hide = defaultedProps.hide;\n\n    if (hide) {\n      return result;\n    }\n\n    var axisId = defaultedProps[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, parentStackGroupsInitialValue);\n  var axisStackGroupsInitialValue = {};\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      var stackGroupsInitialValue = {};\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, stackGroupsInitialValue);\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, axisStackGroupsInitialValue);\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n      type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n\n    if (!domain.length) {\n      return null;\n    }\n\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain([min(tickValues), max(tickValues)]);\n    return {\n      niceTicks: tickValues\n    };\n  }\n\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return {\n      niceTicks: _tickValues\n    };\n  }\n\n  return null;\n};\nexport function getCateCoordinateOfLine(_ref5) {\n  var axis = _ref5.axis,\n      ticks = _ref5.ticks,\n      bandSize = _ref5.bandSize,\n      entry = _ref5.entry,\n      index = _ref5.index,\n      dataKey = _ref5.dataKey;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNil(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !isNil(dataKey) ? dataKey : axis.dataKey);\n  return !isNil(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref6) {\n  var axis = _ref6.axis,\n      ticks = _ref6.ticks,\n      offset = _ref6.offset,\n      bandSize = _ref6.bandSize,\n      entry = _ref6.entry,\n      index = _ref6.index;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref7) {\n  var numericAxis = _ref7.numericAxis;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var minValue = Math.min(domain[0], domain[1]);\n    var maxValue = Math.max(domain[0], domain[1]);\n\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n\n    if (maxValue < 0) {\n      return maxValue;\n    }\n\n    return minValue;\n  }\n\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var _item$type3;\n\n  var defaultedProps = (_item$type3 = item.type) !== null && _item$type3 !== void 0 && _item$type3.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n  var stackId = defaultedProps.stackId;\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group) {\n      var itemIndex = group.items.indexOf(item);\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [min(entry.concat([result[0]]).filter(isNumber)), max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (isFunction(specifiedDomain)) {\n    return specifiedDomain(dataDomain, allowDataOverflow);\n  }\n\n  if (!Array.isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n\n    domain[1] = dataDomain[1] + _value;\n  } else if (isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  // @ts-expect-error we need to rethink scale type\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    // @ts-expect-error we need to rethink scale type\n    var bandWidth = axis.scale.bandwidth();\n\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return isBar ? undefined : 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis ReactElement\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n\n  if (isEqual(specifiedDomain, get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n\n  return specifiedDomain;\n};\nexport var getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n  var defaultedProps = graphicalItem.type.defaultProps ? _objectSpread(_objectSpread({}, graphicalItem.type.defaultProps), graphicalItem.props) : graphicalItem.props;\n  var dataKey = defaultedProps.dataKey,\n      name = defaultedProps.name,\n      unit = defaultedProps.unit,\n      formatter = defaultedProps.formatter,\n      tooltipType = defaultedProps.tooltipType,\n      chartType = defaultedProps.chartType,\n      hide = defaultedProps.hide;\n  return _objectSpread(_objectSpread({}, filterProps(graphicalItem, false)), {}, {\n    dataKey: dataKey,\n    unit: unit,\n    formatter: formatter,\n    name: name || dataKey,\n    color: getMainColorOfGraphicItem(graphicalItem),\n    value: getValueByDataKey(payload, dataKey),\n    type: tooltipType,\n    payload: payload,\n    chartType: chartType,\n    hide: hide\n  });\n};","map":{"version":3,"sources":["C:/Users/hp/Desktop/stock-dashboard-master/stock-dashboard-master/node_modules/recharts/es6/util/ChartUtils.js"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","iter","isArray","len","length","i","arr2","ownKeys","e","r","t","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","key","value","_toPropertyKey","configurable","writable","_toPrimitive","toPrimitive","String","Number","d3Scales","stack","shapeStack","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderNone","max","min","isNil","isFunction","isString","get","flatMap","isNan","upperFirst","isEqual","sortBy","getNiceTickValues","getTickValuesFixedDomain","ErrorBar","findEntryInArray","getPercentValue","isNumber","isNumOrStr","mathSign","uniqueId","filterProps","findAllByType","getDisplayName","getLegendProps","getValueByDataKey","dataKey","defaultValue","getDomainOfDataByKey","data","type","filterNil","flattenData","entry","domain","parseFloat","Infinity","validateData","map","Date","calculateActiveTickIndex","coordinate","_ticks$length","ticks","undefined","unsortedTicks","axis","index","axisType","Math","abs","range","before","cur","after","sameDirectionCoord","diffInterval","curInRange","afterInRange","sameInterval","minValue","maxValue","_i","getMainColorOfGraphicItem","item","_item$type","_ref","displayName","defaultedProps","defaultProps","props","stroke","fill","result","getBarSizeList","_ref2","globalSize","barSize","totalSize","_ref2$stackGroups","stackGroups","numericAxisIds","sgs","stackIds","j","sLen","_sgs$stackIds$j","items","cateAxisId","barItems","indexOf","barItemDefaultProps","barItemProps","selfSize","cateId","stackList","getBarPosition","_ref3","barGap","barCategoryGap","bandSize","_ref3$sizeList","sizeList","maxBarSize","realBarGap","initialValue","useFull","fullBarSize","sum","reduce","res","offset","prev","size","newPosition","position","newRes","concat","_offset","originalSize","appendOffsetOfLegend","_unused","legendBox","children","width","margin","legendWidth","left","right","legendProps","_ref4","boxWidth","boxHeight","height","align","verticalAlign","layout","isErrorBarRelevantForAxis","direction","getDomainOfErrorBars","errorBars","errorBarChild","entryValue","mainValue","errorDomain","prevErrorArr","k","errorValue","lowerValue","upperValue","parseErrorBarsOfAxis","domains","getDomainOfItemsWithSameAxis","tag","isCategoricalAxis","getCoordinatesOfGrid","syncWithTicks","hasMin","hasMax","values","getTicksOfAxis","isGrid","isAll","scale","duplicateDomain","offsetForBand","realScaleType","bandwidth","niceTicks","scaleContent","row","isCategorical","categoricalDomain","tickCount","handlerWeakMap","WeakMap","combineEventHandlers","defaultHandler","childHandler","has","set","childWeakMap","combineHandler","parseScale","chartType","hasBar","scaleBand","scaleLinear","scalePoint","EPS","checkDomainOfScale","first","last","findPositionOfBar","barPosition","child","truncateByDomain","offsetSign","series","m","positive","negative","offsetPositive","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","stackItems","offsetType","dataKeys","offsetAccessor","d","order","getStackGroupsByAxisId","_items","numericAxisId","reverseStackOrder","reverse","parentStackGroupsInitialValue","_item$type2","stackId","hide","axisId","parentGroup","hasStack","childGroup","axisStackGroupsInitialValue","group","stackGroupsInitialValue","g","stackedData","getTicksOfScale","opts","originalDomain","allowDecimals","scaleType","tickValues","_domain","_tickValues","getCateCoordinateOfLine","_ref5","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref6","getBaseValueOfBar","_ref7","numericAxis","getStackedDataOfItem","_item$type3","itemIndex","getDomainOfSingle","getDomainOfStackGroups","startIndex","endIndex","s","MIN_VALUE_REG","MAX_VALUE_REG","parseSpecifiedDomain","specifiedDomain","dataDomain","allowDataOverflow","exec","_value","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","parseDomainOfCategoryAxis","calculatedDomain","axisChild","getTooltipItem","graphicalItem","payload","unit","formatter","tooltipType","color"],"mappings":"AAAA,SAASA,OAAT,CAAiBC,CAAjB,EAAoB;AAAE;;AAA2B,SAAOD,OAAO,GAAG,cAAc,OAAOE,MAArB,IAA+B,YAAY,OAAOA,MAAM,CAACC,QAAzD,GAAoE,UAAUF,CAAV,EAAa;AAAE,WAAO,OAAOA,CAAd;AAAkB,GAArG,GAAwG,UAAUA,CAAV,EAAa;AAAE,WAAOA,CAAC,IAAI,cAAc,OAAOC,MAA1B,IAAoCD,CAAC,CAACG,WAAF,KAAkBF,MAAtD,IAAgED,CAAC,KAAKC,MAAM,CAACG,SAA7E,GAAyF,QAAzF,GAAoG,OAAOJ,CAAlH;AAAsH,GAAvP,EAAyPD,OAAO,CAACC,CAAD,CAAvQ;AAA6Q;;AAC9T,SAASK,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,SAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,2BAA2B,CAACH,GAAD,CAA/E,IAAwFI,kBAAkB,EAAjH;AAAsH;;AACzJ,SAASA,kBAAT,GAA8B;AAAE,QAAM,IAAIC,SAAJ,CAAc,sIAAd,CAAN;AAA8J;;AAC9L,SAASF,2BAAT,CAAqCT,CAArC,EAAwCY,MAAxC,EAAgD;AAAE,MAAI,CAACZ,CAAL,EAAQ;AAAQ,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOa,iBAAiB,CAACb,CAAD,EAAIY,MAAJ,CAAxB;AAAqC,MAAIE,CAAC,GAAGC,MAAM,CAACX,SAAP,CAAiBY,QAAjB,CAA0BC,IAA1B,CAA+BjB,CAA/B,EAAkCkB,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AAAwD,MAAIJ,CAAC,KAAK,QAAN,IAAkBd,CAAC,CAACG,WAAxB,EAAqCW,CAAC,GAAGd,CAAC,CAACG,WAAF,CAAcgB,IAAlB;AAAwB,MAAIL,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOM,KAAK,CAACC,IAAN,CAAWrB,CAAX,CAAP;AAAsB,MAAIc,CAAC,KAAK,WAAN,IAAqB,2CAA2CQ,IAA3C,CAAgDR,CAAhD,CAAzB,EAA6E,OAAOD,iBAAiB,CAACb,CAAD,EAAIY,MAAJ,CAAxB;AAAsC;;AACha,SAASJ,gBAAT,CAA0Be,IAA1B,EAAgC;AAAE,MAAI,OAAOtB,MAAP,KAAkB,WAAlB,IAAiCsB,IAAI,CAACtB,MAAM,CAACC,QAAR,CAAJ,IAAyB,IAA1D,IAAkEqB,IAAI,CAAC,YAAD,CAAJ,IAAsB,IAA5F,EAAkG,OAAOH,KAAK,CAACC,IAAN,CAAWE,IAAX,CAAP;AAA0B;;AAC9J,SAAShB,kBAAT,CAA4BD,GAA5B,EAAiC;AAAE,MAAIc,KAAK,CAACI,OAAN,CAAclB,GAAd,CAAJ,EAAwB,OAAOO,iBAAiB,CAACP,GAAD,CAAxB;AAAgC;;AAC3F,SAASO,iBAAT,CAA2BP,GAA3B,EAAgCmB,GAAhC,EAAqC;AAAE,MAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGnB,GAAG,CAACoB,MAA7B,EAAqCD,GAAG,GAAGnB,GAAG,CAACoB,MAAV;;AAAkB,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,IAAIR,KAAJ,CAAUK,GAAV,CAAvB,EAAuCE,CAAC,GAAGF,GAA3C,EAAgDE,CAAC,EAAjD,EAAqDC,IAAI,CAACD,CAAD,CAAJ,GAAUrB,GAAG,CAACqB,CAAD,CAAb;;AAAkB,SAAOC,IAAP;AAAc;;AACnL,SAASC,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AAAE,MAAIC,CAAC,GAAGjB,MAAM,CAACkB,IAAP,CAAYH,CAAZ,CAAR;;AAAwB,MAAIf,MAAM,CAACmB,qBAAX,EAAkC;AAAE,QAAIlC,CAAC,GAAGe,MAAM,CAACmB,qBAAP,CAA6BJ,CAA7B,CAAR;AAAyCC,IAAAA,CAAC,KAAK/B,CAAC,GAAGA,CAAC,CAACmC,MAAF,CAAS,UAAUJ,CAAV,EAAa;AAAE,aAAOhB,MAAM,CAACqB,wBAAP,CAAgCN,CAAhC,EAAmCC,CAAnC,EAAsCM,UAA7C;AAA0D,KAAlF,CAAT,CAAD,EAAgGL,CAAC,CAACM,IAAF,CAAOC,KAAP,CAAaP,CAAb,EAAgBhC,CAAhB,CAAhG;AAAqH;;AAAC,SAAOgC,CAAP;AAAW;;AAC/P,SAASQ,aAAT,CAAuBV,CAAvB,EAA0B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,SAAS,CAACf,MAA9B,EAAsCK,CAAC,EAAvC,EAA2C;AAAE,QAAIC,CAAC,GAAG,QAAQS,SAAS,CAACV,CAAD,CAAjB,GAAuBU,SAAS,CAACV,CAAD,CAAhC,GAAsC,EAA9C;AAAkDA,IAAAA,CAAC,GAAG,CAAJ,GAAQF,OAAO,CAACd,MAAM,CAACiB,CAAD,CAAP,EAAY,CAAC,CAAb,CAAP,CAAuBU,OAAvB,CAA+B,UAAUX,CAAV,EAAa;AAAEY,MAAAA,eAAe,CAACb,CAAD,EAAIC,CAAJ,EAAOC,CAAC,CAACD,CAAD,CAAR,CAAf;AAA8B,KAA5E,CAAR,GAAwFhB,MAAM,CAAC6B,yBAAP,GAAmC7B,MAAM,CAAC8B,gBAAP,CAAwBf,CAAxB,EAA2Bf,MAAM,CAAC6B,yBAAP,CAAiCZ,CAAjC,CAA3B,CAAnC,GAAqGH,OAAO,CAACd,MAAM,CAACiB,CAAD,CAAP,CAAP,CAAmBU,OAAnB,CAA2B,UAAUX,CAAV,EAAa;AAAEhB,MAAAA,MAAM,CAAC+B,cAAP,CAAsBhB,CAAtB,EAAyBC,CAAzB,EAA4BhB,MAAM,CAACqB,wBAAP,CAAgCJ,CAAhC,EAAmCD,CAAnC,CAA5B;AAAqE,KAA/G,CAA7L;AAAgT;;AAAC,SAAOD,CAAP;AAAW;;AACvb,SAASa,eAAT,CAAyBI,GAAzB,EAA8BC,GAA9B,EAAmCC,KAAnC,EAA0C;AAAED,EAAAA,GAAG,GAAGE,cAAc,CAACF,GAAD,CAApB;;AAA2B,MAAIA,GAAG,IAAID,GAAX,EAAgB;AAAEhC,IAAAA,MAAM,CAAC+B,cAAP,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;AAAEC,MAAAA,KAAK,EAAEA,KAAT;AAAgBZ,MAAAA,UAAU,EAAE,IAA5B;AAAkCc,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEL,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;AAAmB;;AAAC,SAAOF,GAAP;AAAa;;AAC5O,SAASG,cAAT,CAAwBlB,CAAxB,EAA2B;AAAE,MAAIL,CAAC,GAAG0B,YAAY,CAACrB,CAAD,EAAI,QAAJ,CAApB;;AAAmC,SAAO,YAAYjC,OAAO,CAAC4B,CAAD,CAAnB,GAAyBA,CAAzB,GAA6BA,CAAC,GAAG,EAAxC;AAA6C;;AAC7G,SAAS0B,YAAT,CAAsBrB,CAAtB,EAAyBD,CAAzB,EAA4B;AAAE,MAAI,YAAYhC,OAAO,CAACiC,CAAD,CAAnB,IAA0B,CAACA,CAA/B,EAAkC,OAAOA,CAAP;AAAU,MAAIF,CAAC,GAAGE,CAAC,CAAC/B,MAAM,CAACqD,WAAR,CAAT;;AAA+B,MAAI,KAAK,CAAL,KAAWxB,CAAf,EAAkB;AAAE,QAAIH,CAAC,GAAGG,CAAC,CAACb,IAAF,CAAOe,CAAP,EAAUD,CAAC,IAAI,SAAf,CAAR;AAAmC,QAAI,YAAYhC,OAAO,CAAC4B,CAAD,CAAvB,EAA4B,OAAOA,CAAP;AAAU,UAAM,IAAIhB,SAAJ,CAAc,8CAAd,CAAN;AAAsE;;AAAC,SAAO,CAAC,aAAaoB,CAAb,GAAiBwB,MAAjB,GAA0BC,MAA3B,EAAmCxB,CAAnC,CAAP;AAA+C;;AAC5T,OAAO,KAAKyB,QAAZ,MAA0B,yBAA1B;AACA,SAASC,KAAK,IAAIC,UAAlB,EAA8BC,iBAA9B,EAAiDC,eAAjD,EAAkEC,qBAAlE,EAAyFC,iBAAzF,EAA4GC,cAA5G,QAAkI,yBAAlI;AACA,OAAOC,GAAP,MAAgB,YAAhB;AACA,OAAOC,GAAP,MAAgB,YAAhB;AACA,OAAOC,KAAP,MAAkB,cAAlB;AACA,OAAOC,UAAP,MAAuB,mBAAvB;AACA,OAAOC,QAAP,MAAqB,iBAArB;AACA,OAAOC,GAAP,MAAgB,YAAhB;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,OAAOC,KAAP,MAAkB,cAAlB;AACA,OAAOC,UAAP,MAAuB,mBAAvB;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,OAAOC,MAAP,MAAmB,eAAnB;AACA,SAASC,iBAAT,EAA4BC,wBAA5B,QAA4D,gBAA5D;AACA,SAASC,QAAT,QAAyB,uBAAzB;AACA,SAASC,gBAAT,EAA2BC,eAA3B,EAA4CC,QAA5C,EAAsDC,UAAtD,EAAkEC,QAAlE,EAA4EC,QAA5E,QAA4F,aAA5F;AACA,SAASC,WAAT,EAAsBC,aAAtB,EAAqCC,cAArC,QAA2D,cAA3D,C,CACA;AACA;;AAEA,SAASC,cAAT,QAA+B,kBAA/B,C,CAEA;;AACA,SAASA,cAAT;AACA,OAAO,SAASC,iBAAT,CAA2B1C,GAA3B,EAAgC2C,OAAhC,EAAyCC,YAAzC,EAAuD;AAC5D,MAAIxB,KAAK,CAACpB,GAAD,CAAL,IAAcoB,KAAK,CAACuB,OAAD,CAAvB,EAAkC;AAChC,WAAOC,YAAP;AACD;;AACD,MAAIT,UAAU,CAACQ,OAAD,CAAd,EAAyB;AACvB,WAAOpB,GAAG,CAACvB,GAAD,EAAM2C,OAAN,EAAeC,YAAf,CAAV;AACD;;AACD,MAAIvB,UAAU,CAACsB,OAAD,CAAd,EAAyB;AACvB,WAAOA,OAAO,CAAC3C,GAAD,CAAd;AACD;;AACD,SAAO4C,YAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,oBAAT,CAA8BC,IAA9B,EAAoC7C,GAApC,EAAyC8C,IAAzC,EAA+CC,SAA/C,EAA0D;AAC/D,MAAIC,WAAW,GAAGzB,OAAO,CAACsB,IAAD,EAAO,UAAUI,KAAV,EAAiB;AAC/C,WAAOR,iBAAiB,CAACQ,KAAD,EAAQjD,GAAR,CAAxB;AACD,GAFwB,CAAzB;;AAGA,MAAI8C,IAAI,KAAK,QAAb,EAAuB;AACrB;AACA,QAAII,MAAM,GAAGF,WAAW,CAAC7D,MAAZ,CAAmB,UAAU8D,KAAV,EAAiB;AAC/C,aAAOhB,QAAQ,CAACgB,KAAD,CAAR,IAAmBE,UAAU,CAACF,KAAD,CAApC;AACD,KAFY,CAAb;AAGA,WAAOC,MAAM,CAACxE,MAAP,GAAgB,CAACwC,GAAG,CAACgC,MAAD,CAAJ,EAAcjC,GAAG,CAACiC,MAAD,CAAjB,CAAhB,GAA6C,CAACE,QAAD,EAAW,CAACA,QAAZ,CAApD;AACD;;AACD,MAAIC,YAAY,GAAGN,SAAS,GAAGC,WAAW,CAAC7D,MAAZ,CAAmB,UAAU8D,KAAV,EAAiB;AACjE,WAAO,CAAC9B,KAAK,CAAC8B,KAAD,CAAb;AACD,GAF8B,CAAH,GAEvBD,WAFL,CAX+D,CAe/D;;AACA,SAAOK,YAAY,CAACC,GAAb,CAAiB,UAAUL,KAAV,EAAiB;AACvC,WAAOf,UAAU,CAACe,KAAD,CAAV,IAAqBA,KAAK,YAAYM,IAAtC,GAA6CN,KAA7C,GAAqD,EAA5D;AACD,GAFM,CAAP;AAGD;AACD,OAAO,IAAIO,wBAAwB,GAAG,SAASA,wBAAT,CAAkCC,UAAlC,EAA8C;AAClF,MAAIC,aAAJ;;AACA,MAAIC,KAAK,GAAGlE,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBmE,SAAzC,GAAqDnE,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AACA,MAAIoE,aAAa,GAAGpE,SAAS,CAACf,MAAV,GAAmB,CAAnB,GAAuBe,SAAS,CAAC,CAAD,CAAhC,GAAsCmE,SAA1D;AACA,MAAIE,IAAI,GAAGrE,SAAS,CAACf,MAAV,GAAmB,CAAnB,GAAuBe,SAAS,CAAC,CAAD,CAAhC,GAAsCmE,SAAjD;AACA,MAAIG,KAAK,GAAG,CAAC,CAAb;AACA,MAAItF,GAAG,GAAG,CAACiF,aAAa,GAAGC,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACjF,MAArE,MAAiF,IAAjF,IAAyFgF,aAAa,KAAK,KAAK,CAAhH,GAAoHA,aAApH,GAAoI,CAA9I,CANkF,CAQlF;;AACA,MAAIjF,GAAG,IAAI,CAAX,EAAc;AACZ,WAAO,CAAP;AACD;;AACD,MAAIqF,IAAI,IAAIA,IAAI,CAACE,QAAL,KAAkB,WAA1B,IAAyCC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACC,GAAL,CAASJ,IAAI,CAACK,KAAL,CAAW,CAAX,IAAgBL,IAAI,CAACK,KAAL,CAAW,CAAX,CAAzB,IAA0C,GAAnD,KAA2D,IAAxG,EAA8G;AAC5G,QAAIA,KAAK,GAAGL,IAAI,CAACK,KAAjB,CAD4G,CAE5G;;AACA,SAAK,IAAIxF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;AAC5B,UAAIyF,MAAM,GAAGzF,CAAC,GAAG,CAAJ,GAAQkF,aAAa,CAAClF,CAAC,GAAG,CAAL,CAAb,CAAqB8E,UAA7B,GAA0CI,aAAa,CAACpF,GAAG,GAAG,CAAP,CAAb,CAAuBgF,UAA9E;AACA,UAAIY,GAAG,GAAGR,aAAa,CAAClF,CAAD,CAAb,CAAiB8E,UAA3B;AACA,UAAIa,KAAK,GAAG3F,CAAC,IAAIF,GAAG,GAAG,CAAX,GAAeoF,aAAa,CAAC,CAAD,CAAb,CAAiBJ,UAAhC,GAA6CI,aAAa,CAAClF,CAAC,GAAG,CAAL,CAAb,CAAqB8E,UAA9E;AACA,UAAIc,kBAAkB,GAAG,KAAK,CAA9B;;AACA,UAAIpC,QAAQ,CAACkC,GAAG,GAAGD,MAAP,CAAR,KAA2BjC,QAAQ,CAACmC,KAAK,GAAGD,GAAT,CAAvC,EAAsD;AACpD,YAAIG,YAAY,GAAG,EAAnB;;AACA,YAAIrC,QAAQ,CAACmC,KAAK,GAAGD,GAAT,CAAR,KAA0BlC,QAAQ,CAACgC,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAjB,CAAtC,EAA6D;AAC3DI,UAAAA,kBAAkB,GAAGD,KAArB;AACA,cAAIG,UAAU,GAAGJ,GAAG,GAAGF,KAAK,CAAC,CAAD,CAAX,GAAiBA,KAAK,CAAC,CAAD,CAAvC;AACAK,UAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBP,IAAI,CAAC/C,GAAL,CAASuD,UAAT,EAAqB,CAACA,UAAU,GAAGL,MAAd,IAAwB,CAA7C,CAAlB;AACAI,UAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBP,IAAI,CAAChD,GAAL,CAASwD,UAAT,EAAqB,CAACA,UAAU,GAAGL,MAAd,IAAwB,CAA7C,CAAlB;AACD,SALD,MAKO;AACLG,UAAAA,kBAAkB,GAAGH,MAArB;AACA,cAAIM,YAAY,GAAGJ,KAAK,GAAGH,KAAK,CAAC,CAAD,CAAb,GAAmBA,KAAK,CAAC,CAAD,CAA3C;AACAK,UAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBP,IAAI,CAAC/C,GAAL,CAASmD,GAAT,EAAc,CAACK,YAAY,GAAGL,GAAhB,IAAuB,CAArC,CAAlB;AACAG,UAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBP,IAAI,CAAChD,GAAL,CAASoD,GAAT,EAAc,CAACK,YAAY,GAAGL,GAAhB,IAAuB,CAArC,CAAlB;AACD;;AACD,YAAIM,YAAY,GAAG,CAACV,IAAI,CAAC/C,GAAL,CAASmD,GAAT,EAAc,CAACE,kBAAkB,GAAGF,GAAtB,IAA6B,CAA3C,CAAD,EAAgDJ,IAAI,CAAChD,GAAL,CAASoD,GAAT,EAAc,CAACE,kBAAkB,GAAGF,GAAtB,IAA6B,CAA3C,CAAhD,CAAnB;;AACA,YAAIZ,UAAU,GAAGkB,YAAY,CAAC,CAAD,CAAzB,IAAgClB,UAAU,IAAIkB,YAAY,CAAC,CAAD,CAA1D,IAAiElB,UAAU,IAAIe,YAAY,CAAC,CAAD,CAA1B,IAAiCf,UAAU,IAAIe,YAAY,CAAC,CAAD,CAAhI,EAAqI;AACnIT,UAAAA,KAAK,GAAGF,aAAa,CAAClF,CAAD,CAAb,CAAiBoF,KAAzB;AACA;AACD;AACF,OAlBD,MAkBO;AACL,YAAIa,QAAQ,GAAGX,IAAI,CAAC/C,GAAL,CAASkD,MAAT,EAAiBE,KAAjB,CAAf;AACA,YAAIO,QAAQ,GAAGZ,IAAI,CAAChD,GAAL,CAASmD,MAAT,EAAiBE,KAAjB,CAAf;;AACA,YAAIb,UAAU,GAAG,CAACmB,QAAQ,GAAGP,GAAZ,IAAmB,CAAhC,IAAqCZ,UAAU,IAAI,CAACoB,QAAQ,GAAGR,GAAZ,IAAmB,CAA1E,EAA6E;AAC3EN,UAAAA,KAAK,GAAGF,aAAa,CAAClF,CAAD,CAAb,CAAiBoF,KAAzB;AACA;AACD;AACF;AACF;AACF,GAnCD,MAmCO;AACL;AACA,SAAK,IAAIe,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGrG,GAAtB,EAA2BqG,EAAE,EAA7B,EAAiC;AAC/B,UAAIA,EAAE,KAAK,CAAP,IAAYrB,UAAU,IAAI,CAACE,KAAK,CAACmB,EAAD,CAAL,CAAUrB,UAAV,GAAuBE,KAAK,CAACmB,EAAE,GAAG,CAAN,CAAL,CAAcrB,UAAtC,IAAoD,CAA9E,IAAmFqB,EAAE,GAAG,CAAL,IAAUA,EAAE,GAAGrG,GAAG,GAAG,CAArB,IAA0BgF,UAAU,GAAG,CAACE,KAAK,CAACmB,EAAD,CAAL,CAAUrB,UAAV,GAAuBE,KAAK,CAACmB,EAAE,GAAG,CAAN,CAAL,CAAcrB,UAAtC,IAAoD,CAA3F,IAAgGA,UAAU,IAAI,CAACE,KAAK,CAACmB,EAAD,CAAL,CAAUrB,UAAV,GAAuBE,KAAK,CAACmB,EAAE,GAAG,CAAN,CAAL,CAAcrB,UAAtC,IAAoD,CAArP,IAA0PqB,EAAE,KAAKrG,GAAG,GAAG,CAAb,IAAkBgF,UAAU,GAAG,CAACE,KAAK,CAACmB,EAAD,CAAL,CAAUrB,UAAV,GAAuBE,KAAK,CAACmB,EAAE,GAAG,CAAN,CAAL,CAAcrB,UAAtC,IAAoD,CAAjV,EAAoV;AAClVM,QAAAA,KAAK,GAAGJ,KAAK,CAACmB,EAAD,CAAL,CAAUf,KAAlB;AACA;AACD;AACF;AACF;;AACD,SAAOA,KAAP;AACD,CAzDM;AA2DP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIgB,yBAAyB,GAAG,SAASA,yBAAT,CAAmCC,IAAnC,EAAyC;AAC9E,MAAIC,UAAJ;;AACA,MAAIC,IAAI,GAAGF,IAAX;AAAA,MACEG,WAAW,GAAGD,IAAI,CAACpC,IAAL,CAAUqC,WAD1B,CAF8E,CAGvC;;AACvC,MAAIC,cAAc,GAAG,CAACH,UAAU,GAAGD,IAAI,CAAClC,IAAnB,MAA6B,IAA7B,IAAqCmC,UAAU,KAAK,KAAK,CAAzD,IAA8DA,UAAU,CAACI,YAAzE,GAAwF7F,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKwF,IAAI,CAAClC,IAAL,CAAUuC,YAAf,CAAd,EAA4CL,IAAI,CAACM,KAAjD,CAArG,GAA+JN,IAAI,CAACM,KAAzL;AACA,MAAIC,MAAM,GAAGH,cAAc,CAACG,MAA5B;AAAA,MACEC,IAAI,GAAGJ,cAAc,CAACI,IADxB;AAEA,MAAIC,MAAJ;;AACA,UAAQN,WAAR;AACE,SAAK,MAAL;AACEM,MAAAA,MAAM,GAAGF,MAAT;AACA;;AACF,SAAK,MAAL;AACA,SAAK,OAAL;AACEE,MAAAA,MAAM,GAAGF,MAAM,IAAIA,MAAM,KAAK,MAArB,GAA8BA,MAA9B,GAAuCC,IAAhD;AACA;;AACF;AACEC,MAAAA,MAAM,GAAGD,IAAT;AACA;AAVJ;;AAYA,SAAOC,MAAP;AACD,CArBM;AAsBP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,cAAc,GAAG,SAASA,cAAT,CAAwBC,KAAxB,EAA+B;AACzD,MAAIC,UAAU,GAAGD,KAAK,CAACE,OAAvB;AAAA,MACEC,SAAS,GAAGH,KAAK,CAACG,SADpB;AAAA,MAEEC,iBAAiB,GAAGJ,KAAK,CAACK,WAF5B;AAAA,MAGEA,WAAW,GAAGD,iBAAiB,KAAK,KAAK,CAA3B,GAA+B,EAA/B,GAAoCA,iBAHpD;;AAIA,MAAI,CAACC,WAAL,EAAkB;AAChB,WAAO,EAAP;AACD;;AACD,MAAIP,MAAM,GAAG,EAAb;AACA,MAAIQ,cAAc,GAAGlI,MAAM,CAACkB,IAAP,CAAY+G,WAAZ,CAArB;;AACA,OAAK,IAAIrH,CAAC,GAAG,CAAR,EAAWF,GAAG,GAAGwH,cAAc,CAACvH,MAArC,EAA6CC,CAAC,GAAGF,GAAjD,EAAsDE,CAAC,EAAvD,EAA2D;AACzD,QAAIuH,GAAG,GAAGF,WAAW,CAACC,cAAc,CAACtH,CAAD,CAAf,CAAX,CAA+BqH,WAAzC;AACA,QAAIG,QAAQ,GAAGpI,MAAM,CAACkB,IAAP,CAAYiH,GAAZ,CAAf;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAGF,QAAQ,CAACzH,MAAhC,EAAwC0H,CAAC,GAAGC,IAA5C,EAAkDD,CAAC,EAAnD,EAAuD;AACrD,UAAIE,eAAe,GAAGJ,GAAG,CAACC,QAAQ,CAACC,CAAD,CAAT,CAAzB;AAAA,UACEG,KAAK,GAAGD,eAAe,CAACC,KAD1B;AAAA,UAEEC,UAAU,GAAGF,eAAe,CAACE,UAF/B;AAGA,UAAIC,QAAQ,GAAGF,KAAK,CAACpH,MAAN,CAAa,UAAU6F,IAAV,EAAgB;AAC1C,eAAOzC,cAAc,CAACyC,IAAI,CAAClC,IAAN,CAAd,CAA0B4D,OAA1B,CAAkC,KAAlC,KAA4C,CAAnD;AACD,OAFc,CAAf;;AAGA,UAAID,QAAQ,IAAIA,QAAQ,CAAC/H,MAAzB,EAAiC;AAC/B,YAAIiI,mBAAmB,GAAGF,QAAQ,CAAC,CAAD,CAAR,CAAY3D,IAAZ,CAAiBuC,YAA3C;AACA,YAAIuB,YAAY,GAAGD,mBAAmB,KAAK/C,SAAxB,GAAoCpE,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKmH,mBAAL,CAAd,EAAyCF,QAAQ,CAAC,CAAD,CAAR,CAAYnB,KAArD,CAAjD,GAA+GmB,QAAQ,CAAC,CAAD,CAAR,CAAYnB,KAA9I;AACA,YAAIuB,QAAQ,GAAGD,YAAY,CAACf,OAA5B;AACA,YAAIiB,MAAM,GAAGF,YAAY,CAACJ,UAAD,CAAzB;;AACA,YAAI,CAACf,MAAM,CAACqB,MAAD,CAAX,EAAqB;AACnBrB,UAAAA,MAAM,CAACqB,MAAD,CAAN,GAAiB,EAAjB;AACD;;AACD,YAAIjB,OAAO,GAAG1E,KAAK,CAAC0F,QAAD,CAAL,GAAkBjB,UAAlB,GAA+BiB,QAA7C;AACApB,QAAAA,MAAM,CAACqB,MAAD,CAAN,CAAexH,IAAf,CAAoB;AAClB0F,UAAAA,IAAI,EAAEyB,QAAQ,CAAC,CAAD,CADI;AAElBM,UAAAA,SAAS,EAAEN,QAAQ,CAACvI,KAAT,CAAe,CAAf,CAFO;AAGlB2H,UAAAA,OAAO,EAAE1E,KAAK,CAAC0E,OAAD,CAAL,GAAiBjC,SAAjB,GAA6B5B,eAAe,CAAC6D,OAAD,EAAUC,SAAV,EAAqB,CAArB;AAHnC,SAApB;AAKD;AACF;AACF;;AACD,SAAOL,MAAP;AACD,CAtCM;AAuCP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIuB,cAAc,GAAG,SAASA,cAAT,CAAwBC,KAAxB,EAA+B;AACzD,MAAIC,MAAM,GAAGD,KAAK,CAACC,MAAnB;AAAA,MACEC,cAAc,GAAGF,KAAK,CAACE,cADzB;AAAA,MAEEC,QAAQ,GAAGH,KAAK,CAACG,QAFnB;AAAA,MAGEC,cAAc,GAAGJ,KAAK,CAACK,QAHzB;AAAA,MAIEA,QAAQ,GAAGD,cAAc,KAAK,KAAK,CAAxB,GAA4B,EAA5B,GAAiCA,cAJ9C;AAAA,MAKEE,UAAU,GAAGN,KAAK,CAACM,UALrB;AAMA,MAAI9I,GAAG,GAAG6I,QAAQ,CAAC5I,MAAnB;AACA,MAAID,GAAG,GAAG,CAAV,EAAa,OAAO,IAAP;AACb,MAAI+I,UAAU,GAAGxF,eAAe,CAACkF,MAAD,EAASE,QAAT,EAAmB,CAAnB,EAAsB,IAAtB,CAAhC;AACA,MAAI3B,MAAJ;AACA,MAAIgC,YAAY,GAAG,EAAnB,CAXyD,CAazD;;AACA,MAAIH,QAAQ,CAAC,CAAD,CAAR,CAAYzB,OAAZ,KAAwB,CAACyB,QAAQ,CAAC,CAAD,CAAR,CAAYzB,OAAzC,EAAkD;AAChD,QAAI6B,OAAO,GAAG,KAAd;AACA,QAAIC,WAAW,GAAGP,QAAQ,GAAG3I,GAA7B,CAFgD,CAGhD;;AACA,QAAImJ,GAAG,GAAGN,QAAQ,CAACO,MAAT,CAAgB,UAAUC,GAAV,EAAe7E,KAAf,EAAsB;AAC9C,aAAO6E,GAAG,GAAG7E,KAAK,CAAC4C,OAAZ,IAAuB,CAA9B;AACD,KAFS,EAEP,CAFO,CAAV;AAGA+B,IAAAA,GAAG,IAAI,CAACnJ,GAAG,GAAG,CAAP,IAAY+I,UAAnB;;AACA,QAAII,GAAG,IAAIR,QAAX,EAAqB;AACnBQ,MAAAA,GAAG,IAAI,CAACnJ,GAAG,GAAG,CAAP,IAAY+I,UAAnB;AACAA,MAAAA,UAAU,GAAG,CAAb;AACD;;AACD,QAAII,GAAG,IAAIR,QAAP,IAAmBO,WAAW,GAAG,CAArC,EAAwC;AACtCD,MAAAA,OAAO,GAAG,IAAV;AACAC,MAAAA,WAAW,IAAI,GAAf;AACAC,MAAAA,GAAG,GAAGnJ,GAAG,GAAGkJ,WAAZ;AACD;;AACD,QAAII,MAAM,GAAG,CAACX,QAAQ,GAAGQ,GAAZ,IAAmB,CAAnB,IAAwB,CAArC;AACA,QAAII,IAAI,GAAG;AACTD,MAAAA,MAAM,EAAEA,MAAM,GAAGP,UADR;AAETS,MAAAA,IAAI,EAAE;AAFG,KAAX;AAIAxC,IAAAA,MAAM,GAAG6B,QAAQ,CAACO,MAAT,CAAgB,UAAUC,GAAV,EAAe7E,KAAf,EAAsB;AAC7C,UAAIiF,WAAW,GAAG;AAChBlD,QAAAA,IAAI,EAAE/B,KAAK,CAAC+B,IADI;AAEhBmD,QAAAA,QAAQ,EAAE;AACRJ,UAAAA,MAAM,EAAEC,IAAI,CAACD,MAAL,GAAcC,IAAI,CAACC,IAAnB,GAA0BT,UAD1B;AAER;AACAS,UAAAA,IAAI,EAAEP,OAAO,GAAGC,WAAH,GAAiB1E,KAAK,CAAC4C;AAH5B;AAFM,OAAlB;AAQA,UAAIuC,MAAM,GAAG,GAAGC,MAAH,CAAUhL,kBAAkB,CAACyK,GAAD,CAA5B,EAAmC,CAACI,WAAD,CAAnC,CAAb;AACAF,MAAAA,IAAI,GAAGI,MAAM,CAACA,MAAM,CAAC1J,MAAP,GAAgB,CAAjB,CAAN,CAA0ByJ,QAAjC;;AACA,UAAIlF,KAAK,CAAC8D,SAAN,IAAmB9D,KAAK,CAAC8D,SAAN,CAAgBrI,MAAvC,EAA+C;AAC7CuE,QAAAA,KAAK,CAAC8D,SAAN,CAAgBrH,OAAhB,CAAwB,UAAUsF,IAAV,EAAgB;AACtCoD,UAAAA,MAAM,CAAC9I,IAAP,CAAY;AACV0F,YAAAA,IAAI,EAAEA,IADI;AAEVmD,YAAAA,QAAQ,EAAEH;AAFA,WAAZ;AAID,SALD;AAMD;;AACD,aAAOI,MAAP;AACD,KApBQ,EAoBNX,YApBM,CAAT;AAqBD,GA3CD,MA2CO;AACL,QAAIa,OAAO,GAAGtG,eAAe,CAACmF,cAAD,EAAiBC,QAAjB,EAA2B,CAA3B,EAA8B,IAA9B,CAA7B;;AACA,QAAIA,QAAQ,GAAG,IAAIkB,OAAf,GAAyB,CAAC7J,GAAG,GAAG,CAAP,IAAY+I,UAArC,IAAmD,CAAvD,EAA0D;AACxDA,MAAAA,UAAU,GAAG,CAAb;AACD;;AACD,QAAIe,YAAY,GAAG,CAACnB,QAAQ,GAAG,IAAIkB,OAAf,GAAyB,CAAC7J,GAAG,GAAG,CAAP,IAAY+I,UAAtC,IAAoD/I,GAAvE;;AACA,QAAI8J,YAAY,GAAG,CAAnB,EAAsB;AACpBA,MAAAA,YAAY,KAAK,CAAjB;AACD;;AACD,QAAIN,IAAI,GAAGV,UAAU,KAAK,CAACA,UAAhB,GAA6BtD,IAAI,CAAC/C,GAAL,CAASqH,YAAT,EAAuBhB,UAAvB,CAA7B,GAAkEgB,YAA7E;AACA9C,IAAAA,MAAM,GAAG6B,QAAQ,CAACO,MAAT,CAAgB,UAAUC,GAAV,EAAe7E,KAAf,EAAsBtE,CAAtB,EAAyB;AAChD,UAAIyJ,MAAM,GAAG,GAAGC,MAAH,CAAUhL,kBAAkB,CAACyK,GAAD,CAA5B,EAAmC,CAAC;AAC/C9C,QAAAA,IAAI,EAAE/B,KAAK,CAAC+B,IADmC;AAE/CmD,QAAAA,QAAQ,EAAE;AACRJ,UAAAA,MAAM,EAAEO,OAAO,GAAG,CAACC,YAAY,GAAGf,UAAhB,IAA8B7I,CAAxC,GAA4C,CAAC4J,YAAY,GAAGN,IAAhB,IAAwB,CADpE;AAERA,UAAAA,IAAI,EAAEA;AAFE;AAFqC,OAAD,CAAnC,CAAb;;AAOA,UAAIhF,KAAK,CAAC8D,SAAN,IAAmB9D,KAAK,CAAC8D,SAAN,CAAgBrI,MAAvC,EAA+C;AAC7CuE,QAAAA,KAAK,CAAC8D,SAAN,CAAgBrH,OAAhB,CAAwB,UAAUsF,IAAV,EAAgB;AACtCoD,UAAAA,MAAM,CAAC9I,IAAP,CAAY;AACV0F,YAAAA,IAAI,EAAEA,IADI;AAEVmD,YAAAA,QAAQ,EAAEC,MAAM,CAACA,MAAM,CAAC1J,MAAP,GAAgB,CAAjB,CAAN,CAA0ByJ;AAF1B,WAAZ;AAID,SALD;AAMD;;AACD,aAAOC,MAAP;AACD,KAjBQ,EAiBNX,YAjBM,CAAT;AAkBD;;AACD,SAAOhC,MAAP;AACD,CAvFM;AAwFP,OAAO,IAAI+C,oBAAoB,GAAG,SAASA,oBAAT,CAA8BT,MAA9B,EAAsCU,OAAtC,EAA+CnD,KAA/C,EAAsDoD,SAAtD,EAAiE;AACjG,MAAIC,QAAQ,GAAGrD,KAAK,CAACqD,QAArB;AAAA,MACEC,KAAK,GAAGtD,KAAK,CAACsD,KADhB;AAAA,MAEEC,MAAM,GAAGvD,KAAK,CAACuD,MAFjB;AAGA,MAAIC,WAAW,GAAGF,KAAK,IAAIC,MAAM,CAACE,IAAP,IAAe,CAAnB,CAAL,IAA8BF,MAAM,CAACG,KAAP,IAAgB,CAA9C,CAAlB;AACA,MAAIC,WAAW,GAAGzG,cAAc,CAAC;AAC/BmG,IAAAA,QAAQ,EAAEA,QADqB;AAE/BG,IAAAA,WAAW,EAAEA;AAFkB,GAAD,CAAhC;;AAIA,MAAIG,WAAJ,EAAiB;AACf,QAAIC,KAAK,GAAGR,SAAS,IAAI,EAAzB;AAAA,QACES,QAAQ,GAAGD,KAAK,CAACN,KADnB;AAAA,QAEEQ,SAAS,GAAGF,KAAK,CAACG,MAFpB;;AAGA,QAAIC,KAAK,GAAGL,WAAW,CAACK,KAAxB;AAAA,QACEC,aAAa,GAAGN,WAAW,CAACM,aAD9B;AAAA,QAEEC,MAAM,GAAGP,WAAW,CAACO,MAFvB;;AAGA,QAAI,CAACA,MAAM,KAAK,UAAX,IAAyBA,MAAM,KAAK,YAAX,IAA2BD,aAAa,KAAK,QAAvE,KAAoFD,KAAK,KAAK,QAA9F,IAA0GrH,QAAQ,CAAC8F,MAAM,CAACuB,KAAD,CAAP,CAAtH,EAAuI;AACrI,aAAO9J,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKuI,MAAL,CAAd,EAA4B,EAA5B,EAAgCpI,eAAe,CAAC,EAAD,EAAK2J,KAAL,EAAYvB,MAAM,CAACuB,KAAD,CAAN,IAAiBH,QAAQ,IAAI,CAA7B,CAAZ,CAA/C,CAApB;AACD;;AACD,QAAI,CAACK,MAAM,KAAK,YAAX,IAA2BA,MAAM,KAAK,UAAX,IAAyBF,KAAK,KAAK,QAA/D,KAA4EC,aAAa,KAAK,QAA9F,IAA0GtH,QAAQ,CAAC8F,MAAM,CAACwB,aAAD,CAAP,CAAtH,EAA+I;AAC7I,aAAO/J,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKuI,MAAL,CAAd,EAA4B,EAA5B,EAAgCpI,eAAe,CAAC,EAAD,EAAK4J,aAAL,EAAoBxB,MAAM,CAACwB,aAAD,CAAN,IAAyBH,SAAS,IAAI,CAAtC,CAApB,CAA/C,CAApB;AACD;AACF;;AACD,SAAOrB,MAAP;AACD,CAxBM;;AAyBP,IAAI0B,yBAAyB,GAAG,SAASA,yBAAT,CAAmCD,MAAnC,EAA2CxF,QAA3C,EAAqD0F,SAArD,EAAgE;AAC9F,MAAIvI,KAAK,CAAC6C,QAAD,CAAT,EAAqB;AACnB,WAAO,IAAP;AACD;;AACD,MAAIwF,MAAM,KAAK,YAAf,EAA6B;AAC3B,WAAOxF,QAAQ,KAAK,OAApB;AACD;;AACD,MAAIwF,MAAM,KAAK,UAAf,EAA2B;AACzB,WAAOxF,QAAQ,KAAK,OAApB;AACD;;AACD,MAAI0F,SAAS,KAAK,GAAlB,EAAuB;AACrB,WAAO1F,QAAQ,KAAK,OAApB;AACD;;AACD,MAAI0F,SAAS,KAAK,GAAlB,EAAuB;AACrB,WAAO1F,QAAQ,KAAK,OAApB;AACD;;AACD,SAAO,IAAP;AACD,CAjBD;;AAkBA,OAAO,IAAI2F,oBAAoB,GAAG,SAASA,oBAAT,CAA8B9G,IAA9B,EAAoCmC,IAApC,EAA0CtC,OAA1C,EAAmD8G,MAAnD,EAA2DxF,QAA3D,EAAqE;AACrG,MAAI2E,QAAQ,GAAG3D,IAAI,CAACM,KAAL,CAAWqD,QAA1B;AACA,MAAIiB,SAAS,GAAGtH,aAAa,CAACqG,QAAD,EAAW7G,QAAX,CAAb,CAAkC3C,MAAlC,CAAyC,UAAU0K,aAAV,EAAyB;AAChF,WAAOJ,yBAAyB,CAACD,MAAD,EAASxF,QAAT,EAAmB6F,aAAa,CAACvE,KAAd,CAAoBoE,SAAvC,CAAhC;AACD,GAFe,CAAhB;;AAGA,MAAIE,SAAS,IAAIA,SAAS,CAAClL,MAA3B,EAAmC;AACjC,QAAIO,IAAI,GAAG2K,SAAS,CAACtG,GAAV,CAAc,UAAUuG,aAAV,EAAyB;AAChD,aAAOA,aAAa,CAACvE,KAAd,CAAoB5C,OAA3B;AACD,KAFU,CAAX;AAGA,WAAOG,IAAI,CAACgF,MAAL,CAAY,UAAUpC,MAAV,EAAkBxC,KAAlB,EAAyB;AAC1C,UAAI6G,UAAU,GAAGrH,iBAAiB,CAACQ,KAAD,EAAQP,OAAR,CAAlC;AACA,UAAIvB,KAAK,CAAC2I,UAAD,CAAT,EAAuB,OAAOrE,MAAP;AACvB,UAAIsE,SAAS,GAAG3L,KAAK,CAACI,OAAN,CAAcsL,UAAd,IAA4B,CAAC5I,GAAG,CAAC4I,UAAD,CAAJ,EAAkB7I,GAAG,CAAC6I,UAAD,CAArB,CAA5B,GAAiE,CAACA,UAAD,EAAaA,UAAb,CAAjF;AACA,UAAIE,WAAW,GAAG/K,IAAI,CAAC4I,MAAL,CAAY,UAAUoC,YAAV,EAAwBC,CAAxB,EAA2B;AACvD,YAAIC,UAAU,GAAG1H,iBAAiB,CAACQ,KAAD,EAAQiH,CAAR,EAAW,CAAX,CAAlC;AACA,YAAIE,UAAU,GAAGL,SAAS,CAAC,CAAD,CAAT,GAAe9F,IAAI,CAACC,GAAL,CAAS9F,KAAK,CAACI,OAAN,CAAc2L,UAAd,IAA4BA,UAAU,CAAC,CAAD,CAAtC,GAA4CA,UAArD,CAAhC;AACA,YAAIE,UAAU,GAAGN,SAAS,CAAC,CAAD,CAAT,GAAe9F,IAAI,CAACC,GAAL,CAAS9F,KAAK,CAACI,OAAN,CAAc2L,UAAd,IAA4BA,UAAU,CAAC,CAAD,CAAtC,GAA4CA,UAArD,CAAhC;AACA,eAAO,CAAClG,IAAI,CAAC/C,GAAL,CAASkJ,UAAT,EAAqBH,YAAY,CAAC,CAAD,CAAjC,CAAD,EAAwChG,IAAI,CAAChD,GAAL,CAASoJ,UAAT,EAAqBJ,YAAY,CAAC,CAAD,CAAjC,CAAxC,CAAP;AACD,OALiB,EAKf,CAAC7G,QAAD,EAAW,CAACA,QAAZ,CALe,CAAlB;AAMA,aAAO,CAACa,IAAI,CAAC/C,GAAL,CAAS8I,WAAW,CAAC,CAAD,CAApB,EAAyBvE,MAAM,CAAC,CAAD,CAA/B,CAAD,EAAsCxB,IAAI,CAAChD,GAAL,CAAS+I,WAAW,CAAC,CAAD,CAApB,EAAyBvE,MAAM,CAAC,CAAD,CAA/B,CAAtC,CAAP;AACD,KAXM,EAWJ,CAACrC,QAAD,EAAW,CAACA,QAAZ,CAXI,CAAP;AAYD;;AACD,SAAO,IAAP;AACD,CAvBM;AAwBP,OAAO,IAAIkH,oBAAoB,GAAG,SAASA,oBAAT,CAA8BzH,IAA9B,EAAoC0D,KAApC,EAA2C7D,OAA3C,EAAoDsB,QAApD,EAA8DwF,MAA9D,EAAsE;AACtG,MAAIe,OAAO,GAAGhE,KAAK,CAACjD,GAAN,CAAU,UAAU0B,IAAV,EAAgB;AACtC,WAAO2E,oBAAoB,CAAC9G,IAAD,EAAOmC,IAAP,EAAatC,OAAb,EAAsB8G,MAAtB,EAA8BxF,QAA9B,CAA3B;AACD,GAFa,EAEX7E,MAFW,CAEJ,UAAU8D,KAAV,EAAiB;AACzB,WAAO,CAAC9B,KAAK,CAAC8B,KAAD,CAAb;AACD,GAJa,CAAd;;AAKA,MAAIsH,OAAO,IAAIA,OAAO,CAAC7L,MAAvB,EAA+B;AAC7B,WAAO6L,OAAO,CAAC1C,MAAR,CAAe,UAAUpC,MAAV,EAAkBxC,KAAlB,EAAyB;AAC7C,aAAO,CAACgB,IAAI,CAAC/C,GAAL,CAASuE,MAAM,CAAC,CAAD,CAAf,EAAoBxC,KAAK,CAAC,CAAD,CAAzB,CAAD,EAAgCgB,IAAI,CAAChD,GAAL,CAASwE,MAAM,CAAC,CAAD,CAAf,EAAoBxC,KAAK,CAAC,CAAD,CAAzB,CAAhC,CAAP;AACD,KAFM,EAEJ,CAACG,QAAD,EAAW,CAACA,QAAZ,CAFI,CAAP;AAGD;;AACD,SAAO,IAAP;AACD,CAZM;AAcP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIoH,4BAA4B,GAAG,SAASA,4BAAT,CAAsC3H,IAAtC,EAA4C0D,KAA5C,EAAmDzD,IAAnD,EAAyD0G,MAAzD,EAAiEzG,SAAjE,EAA4E;AACpH,MAAIwH,OAAO,GAAGhE,KAAK,CAACjD,GAAN,CAAU,UAAU0B,IAAV,EAAgB;AACtC,QAAItC,OAAO,GAAGsC,IAAI,CAACM,KAAL,CAAW5C,OAAzB;;AACA,QAAII,IAAI,KAAK,QAAT,IAAqBJ,OAAzB,EAAkC;AAChC,aAAOiH,oBAAoB,CAAC9G,IAAD,EAAOmC,IAAP,EAAatC,OAAb,EAAsB8G,MAAtB,CAApB,IAAqD5G,oBAAoB,CAACC,IAAD,EAAOH,OAAP,EAAgBI,IAAhB,EAAsBC,SAAtB,CAAhF;AACD;;AACD,WAAOH,oBAAoB,CAACC,IAAD,EAAOH,OAAP,EAAgBI,IAAhB,EAAsBC,SAAtB,CAA3B;AACD,GANa,CAAd;;AAOA,MAAID,IAAI,KAAK,QAAb,EAAuB;AACrB;AACA,WAAOyH,OAAO,CAAC1C,MAAR,EACP;AACA;AACA,cAAUpC,MAAV,EAAkBxC,KAAlB,EAAyB;AACvB,aAAO,CAACgB,IAAI,CAAC/C,GAAL,CAASuE,MAAM,CAAC,CAAD,CAAf,EAAoBxC,KAAK,CAAC,CAAD,CAAzB,CAAD,EAAgCgB,IAAI,CAAChD,GAAL,CAASwE,MAAM,CAAC,CAAD,CAAf,EAAoBxC,KAAK,CAAC,CAAD,CAAzB,CAAhC,CAAP;AACD,KALM,EAKJ,CAACG,QAAD,EAAW,CAACA,QAAZ,CALI,CAAP;AAMD;;AACD,MAAIqH,GAAG,GAAG,EAAV,CAjBoH,CAkBpH;;AACA,SAAOF,OAAO,CAAC1C,MAAR,CAAe,UAAUpC,MAAV,EAAkBxC,KAAlB,EAAyB;AAC7C,SAAK,IAAItE,CAAC,GAAG,CAAR,EAAWF,GAAG,GAAGwE,KAAK,CAACvE,MAA5B,EAAoCC,CAAC,GAAGF,GAAxC,EAA6CE,CAAC,EAA9C,EAAkD;AAChD;AACA,UAAI,CAAC8L,GAAG,CAACxH,KAAK,CAACtE,CAAD,CAAN,CAAR,EAAoB;AAClB;AACA8L,QAAAA,GAAG,CAACxH,KAAK,CAACtE,CAAD,CAAN,CAAH,GAAgB,IAAhB,CAFkB,CAIlB;;AACA8G,QAAAA,MAAM,CAACnG,IAAP,CAAY2D,KAAK,CAACtE,CAAD,CAAjB;AACD;AACF;;AACD,WAAO8G,MAAP;AACD,GAZM,EAYJ,EAZI,CAAP;AAaD,CAhCM;AAiCP,OAAO,IAAIiF,iBAAiB,GAAG,SAASA,iBAAT,CAA2BlB,MAA3B,EAAmCxF,QAAnC,EAA6C;AAC1E,SAAOwF,MAAM,KAAK,YAAX,IAA2BxF,QAAQ,KAAK,OAAxC,IAAmDwF,MAAM,KAAK,UAAX,IAAyBxF,QAAQ,KAAK,OAAzF,IAAoGwF,MAAM,KAAK,SAAX,IAAwBxF,QAAQ,KAAK,WAAzI,IAAwJwF,MAAM,KAAK,QAAX,IAAuBxF,QAAQ,KAAK,YAAnM;AACD,CAFM;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAI2G,oBAAoB,GAAG,SAASA,oBAAT,CAA8BhH,KAA9B,EAAqCiB,QAArC,EAA+CC,QAA/C,EAAyD+F,aAAzD,EAAwE;AACxG,MAAIA,aAAJ,EAAmB;AACjB,WAAOjH,KAAK,CAACL,GAAN,CAAU,UAAUL,KAAV,EAAiB;AAChC,aAAOA,KAAK,CAACQ,UAAb;AACD,KAFM,CAAP;AAGD;;AACD,MAAIoH,MAAJ,EAAYC,MAAZ;AACA,MAAIC,MAAM,GAAGpH,KAAK,CAACL,GAAN,CAAU,UAAUL,KAAV,EAAiB;AACtC,QAAIA,KAAK,CAACQ,UAAN,KAAqBmB,QAAzB,EAAmC;AACjCiG,MAAAA,MAAM,GAAG,IAAT;AACD;;AACD,QAAI5H,KAAK,CAACQ,UAAN,KAAqBoB,QAAzB,EAAmC;AACjCiG,MAAAA,MAAM,GAAG,IAAT;AACD;;AACD,WAAO7H,KAAK,CAACQ,UAAb;AACD,GARY,CAAb;;AASA,MAAI,CAACoH,MAAL,EAAa;AACXE,IAAAA,MAAM,CAACzL,IAAP,CAAYsF,QAAZ;AACD;;AACD,MAAI,CAACkG,MAAL,EAAa;AACXC,IAAAA,MAAM,CAACzL,IAAP,CAAYuF,QAAZ;AACD;;AACD,SAAOkG,MAAP;AACD,CAvBM;AAyBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,cAAc,GAAG,SAASA,cAAT,CAAwBlH,IAAxB,EAA8BmH,MAA9B,EAAsCC,KAAtC,EAA6C;AACvE,MAAI,CAACpH,IAAL,EAAW,OAAO,IAAP;AACX,MAAIqH,KAAK,GAAGrH,IAAI,CAACqH,KAAjB;AACA,MAAIC,eAAe,GAAGtH,IAAI,CAACsH,eAA3B;AAAA,MACEtI,IAAI,GAAGgB,IAAI,CAAChB,IADd;AAAA,MAEEqB,KAAK,GAAGL,IAAI,CAACK,KAFf;AAGA,MAAIkH,aAAa,GAAGvH,IAAI,CAACwH,aAAL,KAAuB,WAAvB,GAAqCH,KAAK,CAACI,SAAN,KAAoB,CAAzD,GAA6D,CAAjF;AACA,MAAIxD,MAAM,GAAG,CAACkD,MAAM,IAAIC,KAAX,KAAqBpI,IAAI,KAAK,UAA9B,IAA4CqI,KAAK,CAACI,SAAlD,GAA8DJ,KAAK,CAACI,SAAN,KAAoBF,aAAlF,GAAkG,CAA/G;AACAtD,EAAAA,MAAM,GAAGjE,IAAI,CAACE,QAAL,KAAkB,WAAlB,IAAiC,CAACG,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACzF,MAArD,KAAgE,CAAjG,GAAqGyD,QAAQ,CAACgC,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAjB,CAAR,GAAgC,CAAhC,GAAoC4D,MAAzI,GAAkJA,MAA3J,CARuE,CAUvE;;AACA,MAAIkD,MAAM,KAAKnH,IAAI,CAACH,KAAL,IAAcG,IAAI,CAAC0H,SAAxB,CAAV,EAA8C;AAC5C,QAAI/F,MAAM,GAAG,CAAC3B,IAAI,CAACH,KAAL,IAAcG,IAAI,CAAC0H,SAApB,EAA+BlI,GAA/B,CAAmC,UAAUL,KAAV,EAAiB;AAC/D,UAAIwI,YAAY,GAAGL,eAAe,GAAGA,eAAe,CAAC1E,OAAhB,CAAwBzD,KAAxB,CAAH,GAAoCA,KAAtE;AACA,aAAO;AACL;AACA;AACAQ,QAAAA,UAAU,EAAE0H,KAAK,CAACM,YAAD,CAAL,GAAsB1D,MAH7B;AAIL9H,QAAAA,KAAK,EAAEgD,KAJF;AAKL8E,QAAAA,MAAM,EAAEA;AALH,OAAP;AAOD,KATY,CAAb;AAUA,WAAOtC,MAAM,CAACtG,MAAP,CAAc,UAAUuM,GAAV,EAAe;AAClC,aAAO,CAAClK,KAAK,CAACkK,GAAG,CAACjI,UAAL,CAAb;AACD,KAFM,CAAP;AAGD,GAzBsE,CA2BvE;;;AACA,MAAIK,IAAI,CAAC6H,aAAL,IAAsB7H,IAAI,CAAC8H,iBAA/B,EAAkD;AAChD,WAAO9H,IAAI,CAAC8H,iBAAL,CAAuBtI,GAAvB,CAA2B,UAAUL,KAAV,EAAiBc,KAAjB,EAAwB;AACxD,aAAO;AACLN,QAAAA,UAAU,EAAE0H,KAAK,CAAClI,KAAD,CAAL,GAAe8E,MADtB;AAEL9H,QAAAA,KAAK,EAAEgD,KAFF;AAGLc,QAAAA,KAAK,EAAEA,KAHF;AAILgE,QAAAA,MAAM,EAAEA;AAJH,OAAP;AAMD,KAPM,CAAP;AAQD;;AACD,MAAIoD,KAAK,CAACxH,KAAN,IAAe,CAACuH,KAApB,EAA2B;AACzB,WAAOC,KAAK,CAACxH,KAAN,CAAYG,IAAI,CAAC+H,SAAjB,EAA4BvI,GAA5B,CAAgC,UAAUL,KAAV,EAAiB;AACtD,aAAO;AACLQ,QAAAA,UAAU,EAAE0H,KAAK,CAAClI,KAAD,CAAL,GAAe8E,MADtB;AAEL9H,QAAAA,KAAK,EAAEgD,KAFF;AAGL8E,QAAAA,MAAM,EAAEA;AAHH,OAAP;AAKD,KANM,CAAP;AAOD,GA9CsE,CAgDvE;;;AACA,SAAOoD,KAAK,CAACjI,MAAN,GAAeI,GAAf,CAAmB,UAAUL,KAAV,EAAiBc,KAAjB,EAAwB;AAChD,WAAO;AACLN,MAAAA,UAAU,EAAE0H,KAAK,CAAClI,KAAD,CAAL,GAAe8E,MADtB;AAEL9H,MAAAA,KAAK,EAAEmL,eAAe,GAAGA,eAAe,CAACnI,KAAD,CAAlB,GAA4BA,KAF7C;AAGLc,MAAAA,KAAK,EAAEA,KAHF;AAILgE,MAAAA,MAAM,EAAEA;AAJH,KAAP;AAMD,GAPM,CAAP;AAQD,CAzDM;AA2DP;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI+D,cAAc,GAAG,IAAIC,OAAJ,EAArB;AACA,OAAO,IAAIC,oBAAoB,GAAG,SAASA,oBAAT,CAA8BC,cAA9B,EAA8CC,YAA9C,EAA4D;AAC5F,MAAI,OAAOA,YAAP,KAAwB,UAA5B,EAAwC;AACtC,WAAOD,cAAP;AACD;;AACD,MAAI,CAACH,cAAc,CAACK,GAAf,CAAmBF,cAAnB,CAAL,EAAyC;AACvCH,IAAAA,cAAc,CAACM,GAAf,CAAmBH,cAAnB,EAAmC,IAAIF,OAAJ,EAAnC;AACD;;AACD,MAAIM,YAAY,GAAGP,cAAc,CAACxK,GAAf,CAAmB2K,cAAnB,CAAnB;;AACA,MAAII,YAAY,CAACF,GAAb,CAAiBD,YAAjB,CAAJ,EAAoC;AAClC,WAAOG,YAAY,CAAC/K,GAAb,CAAiB4K,YAAjB,CAAP;AACD;;AACD,MAAII,cAAc,GAAG,SAASA,cAAT,GAA0B;AAC7CL,IAAAA,cAAc,CAAC1M,KAAf,CAAqB,KAAK,CAA1B,EAA6BE,SAA7B;AACAyM,IAAAA,YAAY,CAAC3M,KAAb,CAAmB,KAAK,CAAxB,EAA2BE,SAA3B;AACD,GAHD;;AAIA4M,EAAAA,YAAY,CAACD,GAAb,CAAiBF,YAAjB,EAA+BI,cAA/B;AACA,SAAOA,cAAP;AACD,CAjBM;AAmBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,UAAU,GAAG,SAASA,UAAT,CAAoBzI,IAApB,EAA0B0I,SAA1B,EAAqCC,MAArC,EAA6C;AACnE,MAAItB,KAAK,GAAGrH,IAAI,CAACqH,KAAjB;AAAA,MACErI,IAAI,GAAGgB,IAAI,CAAChB,IADd;AAAA,MAEE0G,MAAM,GAAG1F,IAAI,CAAC0F,MAFhB;AAAA,MAGExF,QAAQ,GAAGF,IAAI,CAACE,QAHlB;;AAIA,MAAImH,KAAK,KAAK,MAAd,EAAsB;AACpB,QAAI3B,MAAM,KAAK,QAAX,IAAuBxF,QAAQ,KAAK,YAAxC,EAAsD;AACpD,aAAO;AACLmH,QAAAA,KAAK,EAAE1K,QAAQ,CAACiM,SAAT,EADF;AAELpB,QAAAA,aAAa,EAAE;AAFV,OAAP;AAID;;AACD,QAAI9B,MAAM,KAAK,QAAX,IAAuBxF,QAAQ,KAAK,WAAxC,EAAqD;AACnD,aAAO;AACLmH,QAAAA,KAAK,EAAE1K,QAAQ,CAACkM,WAAT,EADF;AAELrB,QAAAA,aAAa,EAAE;AAFV,OAAP;AAID;;AACD,QAAIxI,IAAI,KAAK,UAAT,IAAuB0J,SAAvB,KAAqCA,SAAS,CAAC9F,OAAV,CAAkB,WAAlB,KAAkC,CAAlC,IAAuC8F,SAAS,CAAC9F,OAAV,CAAkB,WAAlB,KAAkC,CAAzE,IAA8E8F,SAAS,CAAC9F,OAAV,CAAkB,eAAlB,KAAsC,CAAtC,IAA2C,CAAC+F,MAA/J,CAAJ,EAA4K;AAC1K,aAAO;AACLtB,QAAAA,KAAK,EAAE1K,QAAQ,CAACmM,UAAT,EADF;AAELtB,QAAAA,aAAa,EAAE;AAFV,OAAP;AAID;;AACD,QAAIxI,IAAI,KAAK,UAAb,EAAyB;AACvB,aAAO;AACLqI,QAAAA,KAAK,EAAE1K,QAAQ,CAACiM,SAAT,EADF;AAELpB,QAAAA,aAAa,EAAE;AAFV,OAAP;AAID;;AACD,WAAO;AACLH,MAAAA,KAAK,EAAE1K,QAAQ,CAACkM,WAAT,EADF;AAELrB,MAAAA,aAAa,EAAE;AAFV,KAAP;AAID;;AACD,MAAIjK,QAAQ,CAAC8J,KAAD,CAAZ,EAAqB;AACnB,QAAIhN,IAAI,GAAG,QAAQkK,MAAR,CAAe5G,UAAU,CAAC0J,KAAD,CAAzB,CAAX;AACA,WAAO;AACLA,MAAAA,KAAK,EAAE,CAAC1K,QAAQ,CAACtC,IAAD,CAAR,IAAkBsC,QAAQ,CAACmM,UAA5B,GADF;AAELtB,MAAAA,aAAa,EAAE7K,QAAQ,CAACtC,IAAD,CAAR,GAAiBA,IAAjB,GAAwB;AAFlC,KAAP;AAID;;AACD,SAAOiD,UAAU,CAAC+J,KAAD,CAAV,GAAoB;AACzBA,IAAAA,KAAK,EAAEA;AADkB,GAApB,GAEH;AACFA,IAAAA,KAAK,EAAE1K,QAAQ,CAACmM,UAAT,EADL;AAEFtB,IAAAA,aAAa,EAAE;AAFb,GAFJ;AAMD,CAhDM;AAiDP,IAAIuB,GAAG,GAAG,IAAV;AACA,OAAO,IAAIC,kBAAkB,GAAG,SAASA,kBAAT,CAA4B3B,KAA5B,EAAmC;AACjE,MAAIjI,MAAM,GAAGiI,KAAK,CAACjI,MAAN,EAAb;;AACA,MAAI,CAACA,MAAD,IAAWA,MAAM,CAACxE,MAAP,IAAiB,CAAhC,EAAmC;AACjC;AACD;;AACD,MAAID,GAAG,GAAGyE,MAAM,CAACxE,MAAjB;AACA,MAAIyF,KAAK,GAAGgH,KAAK,CAAChH,KAAN,EAAZ;AACA,MAAIS,QAAQ,GAAGX,IAAI,CAAC/C,GAAL,CAASiD,KAAK,CAAC,CAAD,CAAd,EAAmBA,KAAK,CAAC,CAAD,CAAxB,IAA+B0I,GAA9C;AACA,MAAIhI,QAAQ,GAAGZ,IAAI,CAAChD,GAAL,CAASkD,KAAK,CAAC,CAAD,CAAd,EAAmBA,KAAK,CAAC,CAAD,CAAxB,IAA+B0I,GAA9C;AACA,MAAIE,KAAK,GAAG5B,KAAK,CAACjI,MAAM,CAAC,CAAD,CAAP,CAAjB;AACA,MAAI8J,IAAI,GAAG7B,KAAK,CAACjI,MAAM,CAACzE,GAAG,GAAG,CAAP,CAAP,CAAhB;;AACA,MAAIsO,KAAK,GAAGnI,QAAR,IAAoBmI,KAAK,GAAGlI,QAA5B,IAAwCmI,IAAI,GAAGpI,QAA/C,IAA2DoI,IAAI,GAAGnI,QAAtE,EAAgF;AAC9EsG,IAAAA,KAAK,CAACjI,MAAN,CAAa,CAACA,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAACzE,GAAG,GAAG,CAAP,CAAlB,CAAb;AACD;AACF,CAdM;AAeP,OAAO,IAAIwO,iBAAiB,GAAG,SAASA,iBAAT,CAA2BC,WAA3B,EAAwCC,KAAxC,EAA+C;AAC5E,MAAI,CAACD,WAAL,EAAkB;AAChB,WAAO,IAAP;AACD;;AACD,OAAK,IAAIvO,CAAC,GAAG,CAAR,EAAWF,GAAG,GAAGyO,WAAW,CAACxO,MAAlC,EAA0CC,CAAC,GAAGF,GAA9C,EAAmDE,CAAC,EAApD,EAAwD;AACtD,QAAIuO,WAAW,CAACvO,CAAD,CAAX,CAAeqG,IAAf,KAAwBmI,KAA5B,EAAmC;AACjC,aAAOD,WAAW,CAACvO,CAAD,CAAX,CAAewJ,QAAtB;AACD;AACF;;AACD,SAAO,IAAP;AACD,CAVM;AAYP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIiF,gBAAgB,GAAG,SAASA,gBAAT,CAA0BnN,KAA1B,EAAiCiD,MAAjC,EAAyC;AACrE,MAAI,CAACA,MAAD,IAAWA,MAAM,CAACxE,MAAP,KAAkB,CAA7B,IAAkC,CAACuD,QAAQ,CAACiB,MAAM,CAAC,CAAD,CAAP,CAA3C,IAA0D,CAACjB,QAAQ,CAACiB,MAAM,CAAC,CAAD,CAAP,CAAvE,EAAoF;AAClF,WAAOjD,KAAP;AACD;;AACD,MAAI2E,QAAQ,GAAGX,IAAI,CAAC/C,GAAL,CAASgC,MAAM,CAAC,CAAD,CAAf,EAAoBA,MAAM,CAAC,CAAD,CAA1B,CAAf;AACA,MAAI2B,QAAQ,GAAGZ,IAAI,CAAChD,GAAL,CAASiC,MAAM,CAAC,CAAD,CAAf,EAAoBA,MAAM,CAAC,CAAD,CAA1B,CAAf;AACA,MAAIuC,MAAM,GAAG,CAACxF,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,CAAb;;AACA,MAAI,CAACgC,QAAQ,CAAChC,KAAK,CAAC,CAAD,CAAN,CAAT,IAAuBA,KAAK,CAAC,CAAD,CAAL,GAAW2E,QAAtC,EAAgD;AAC9Ca,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYb,QAAZ;AACD;;AACD,MAAI,CAAC3C,QAAQ,CAAChC,KAAK,CAAC,CAAD,CAAN,CAAT,IAAuBA,KAAK,CAAC,CAAD,CAAL,GAAW4E,QAAtC,EAAgD;AAC9CY,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYZ,QAAZ;AACD;;AACD,MAAIY,MAAM,CAAC,CAAD,CAAN,GAAYZ,QAAhB,EAA0B;AACxBY,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYZ,QAAZ;AACD;;AACD,MAAIY,MAAM,CAAC,CAAD,CAAN,GAAYb,QAAhB,EAA0B;AACxBa,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYb,QAAZ;AACD;;AACD,SAAOa,MAAP;AACD,CApBM;AAsBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAI4H,UAAU,GAAG,SAASA,UAAT,CAAoBC,MAApB,EAA4B;AAClD,MAAIxP,CAAC,GAAGwP,MAAM,CAAC5O,MAAf;;AACA,MAAIZ,CAAC,IAAI,CAAT,EAAY;AACV;AACD;;AACD,OAAK,IAAIsI,CAAC,GAAG,CAAR,EAAWmH,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAN,CAAU5O,MAA9B,EAAsC0H,CAAC,GAAGmH,CAA1C,EAA6C,EAAEnH,CAA/C,EAAkD;AAChD,QAAIoH,QAAQ,GAAG,CAAf;AACA,QAAIC,QAAQ,GAAG,CAAf;;AACA,SAAK,IAAI9O,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,CAApB,EAAuB,EAAEa,CAAzB,EAA4B;AAC1B,UAAIsB,KAAK,GAAGuB,KAAK,CAAC8L,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAD,CAAL,GAAyBkH,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAzB,GAA2CkH,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAvD;AAEA;;AACA,UAAInG,KAAK,IAAI,CAAb,EAAgB;AACdqN,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkBoH,QAAlB;AACAF,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkBoH,QAAQ,GAAGvN,KAA7B;AACAuN,QAAAA,QAAQ,GAAGF,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAX;AACD,OAJD,MAIO;AACLkH,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkBqH,QAAlB;AACAH,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkBqH,QAAQ,GAAGxN,KAA7B;AACAwN,QAAAA,QAAQ,GAAGH,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAX;AACD;AACD;;AACD;AACF;AACF,CAxBM;AA0BP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIsH,cAAc,GAAG,SAASA,cAAT,CAAwBJ,MAAxB,EAAgC;AAC1D,MAAIxP,CAAC,GAAGwP,MAAM,CAAC5O,MAAf;;AACA,MAAIZ,CAAC,IAAI,CAAT,EAAY;AACV;AACD;;AACD,OAAK,IAAIsI,CAAC,GAAG,CAAR,EAAWmH,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAN,CAAU5O,MAA9B,EAAsC0H,CAAC,GAAGmH,CAA1C,EAA6C,EAAEnH,CAA/C,EAAkD;AAChD,QAAIoH,QAAQ,GAAG,CAAf;;AACA,SAAK,IAAI7O,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,CAApB,EAAuB,EAAEa,CAAzB,EAA4B;AAC1B,UAAIsB,KAAK,GAAGuB,KAAK,CAAC8L,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAD,CAAL,GAAyBkH,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAzB,GAA2CkH,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAvD;AAEA;;AACA,UAAInG,KAAK,IAAI,CAAb,EAAgB;AACdqN,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkBoH,QAAlB;AACAF,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkBoH,QAAQ,GAAGvN,KAA7B;AACAuN,QAAAA,QAAQ,GAAGF,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,CAAX;AACD,OAJD,MAIO;AACLkH,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkB,CAAlB;AACAkH,QAAAA,MAAM,CAAC3O,CAAD,CAAN,CAAUyH,CAAV,EAAa,CAAb,IAAkB,CAAlB;AACD;AACD;;AACD;AACF;AACF,CAtBM;AAwBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIuH,gBAAgB,GAAG;AACrBC,EAAAA,IAAI,EAAEP,UADe;AAErB;AACAQ,EAAAA,MAAM,EAAEjN,iBAHa;AAIrB;AACAkN,EAAAA,IAAI,EAAEjN,eALe;AAMrB;AACAkN,EAAAA,UAAU,EAAEjN,qBAPS;AAQrB;AACAkN,EAAAA,MAAM,EAAEjN,iBATa;AAUrByM,EAAAA,QAAQ,EAAEE;AAVW,CAAvB;AAYA,OAAO,IAAIO,cAAc,GAAG,SAASA,cAAT,CAAwBpL,IAAxB,EAA8BqL,UAA9B,EAA0CC,UAA1C,EAAsD;AAChF,MAAIC,QAAQ,GAAGF,UAAU,CAAC5K,GAAX,CAAe,UAAU0B,IAAV,EAAgB;AAC5C,WAAOA,IAAI,CAACM,KAAL,CAAW5C,OAAlB;AACD,GAFc,CAAf;AAGA,MAAI2L,cAAc,GAAGV,gBAAgB,CAACQ,UAAD,CAArC;AACA,MAAIzN,KAAK,GAAGC,UAAU,GACtB;AADsB,GAErB1B,IAFW,CAENmP,QAFM,EAEInO,KAFJ,CAEU,UAAUqO,CAAV,EAAatO,GAAb,EAAkB;AACtC,WAAO,CAACyC,iBAAiB,CAAC6L,CAAD,EAAItO,GAAJ,EAAS,CAAT,CAAzB;AACD,GAJW,EAITuO,KAJS,CAIHvN,cAJG,EAKZ;AALY,GAMX+G,MANW,CAMJsG,cANI,CAAZ;AAOA,SAAO3N,KAAK,CAACmC,IAAD,CAAZ;AACD,CAbM;AAcP,OAAO,IAAI2L,sBAAsB,GAAG,SAASA,sBAAT,CAAgC3L,IAAhC,EAAsC4L,MAAtC,EAA8CC,aAA9C,EAA6DlI,UAA7D,EAAyE2H,UAAzE,EAAqFQ,iBAArF,EAAwG;AAC1I,MAAI,CAAC9L,IAAL,EAAW;AACT,WAAO,IAAP;AACD,GAHyI,CAK1I;;;AACA,MAAI0D,KAAK,GAAGoI,iBAAiB,GAAGF,MAAM,CAACG,OAAP,EAAH,GAAsBH,MAAnD;AACA,MAAII,6BAA6B,GAAG,EAApC;AACA,MAAI7I,WAAW,GAAGO,KAAK,CAACsB,MAAN,CAAa,UAAUpC,MAAV,EAAkBT,IAAlB,EAAwB;AACrD,QAAI8J,WAAJ;;AACA,QAAI1J,cAAc,GAAG,CAAC0J,WAAW,GAAG9J,IAAI,CAAClC,IAApB,MAA8B,IAA9B,IAAsCgM,WAAW,KAAK,KAAK,CAA3D,IAAgEA,WAAW,CAACzJ,YAA5E,GAA2F7F,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKwF,IAAI,CAAClC,IAAL,CAAUuC,YAAf,CAAd,EAA4CL,IAAI,CAACM,KAAjD,CAAxG,GAAkKN,IAAI,CAACM,KAA5L;AACA,QAAIyJ,OAAO,GAAG3J,cAAc,CAAC2J,OAA7B;AAAA,QACEC,IAAI,GAAG5J,cAAc,CAAC4J,IADxB;;AAEA,QAAIA,IAAJ,EAAU;AACR,aAAOvJ,MAAP;AACD;;AACD,QAAIwJ,MAAM,GAAG7J,cAAc,CAACsJ,aAAD,CAA3B;AACA,QAAIQ,WAAW,GAAGzJ,MAAM,CAACwJ,MAAD,CAAN,IAAkB;AAClCE,MAAAA,QAAQ,EAAE,KADwB;AAElCnJ,MAAAA,WAAW,EAAE;AAFqB,KAApC;;AAIA,QAAI9D,UAAU,CAAC6M,OAAD,CAAd,EAAyB;AACvB,UAAIK,UAAU,GAAGF,WAAW,CAAClJ,WAAZ,CAAwB+I,OAAxB,KAAoC;AACnDL,QAAAA,aAAa,EAAEA,aADoC;AAEnDlI,QAAAA,UAAU,EAAEA,UAFuC;AAGnDD,QAAAA,KAAK,EAAE;AAH4C,OAArD;AAKA6I,MAAAA,UAAU,CAAC7I,KAAX,CAAiBjH,IAAjB,CAAsB0F,IAAtB;AACAkK,MAAAA,WAAW,CAACC,QAAZ,GAAuB,IAAvB;AACAD,MAAAA,WAAW,CAAClJ,WAAZ,CAAwB+I,OAAxB,IAAmCK,UAAnC;AACD,KATD,MASO;AACLF,MAAAA,WAAW,CAAClJ,WAAZ,CAAwB5D,QAAQ,CAAC,WAAD,CAAhC,IAAiD;AAC/CsM,QAAAA,aAAa,EAAEA,aADgC;AAE/ClI,QAAAA,UAAU,EAAEA,UAFmC;AAG/CD,QAAAA,KAAK,EAAE,CAACvB,IAAD;AAHwC,OAAjD;AAKD;;AACD,WAAOxF,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKiG,MAAL,CAAd,EAA4B,EAA5B,EAAgC9F,eAAe,CAAC,EAAD,EAAKsP,MAAL,EAAaC,WAAb,CAA/C,CAApB;AACD,GA9BiB,EA8BfL,6BA9Be,CAAlB;AA+BA,MAAIQ,2BAA2B,GAAG,EAAlC;AACA,SAAOtR,MAAM,CAACkB,IAAP,CAAY+G,WAAZ,EAAyB6B,MAAzB,CAAgC,UAAUpC,MAAV,EAAkBwJ,MAAlB,EAA0B;AAC/D,QAAIK,KAAK,GAAGtJ,WAAW,CAACiJ,MAAD,CAAvB;;AACA,QAAIK,KAAK,CAACH,QAAV,EAAoB;AAClB,UAAII,uBAAuB,GAAG,EAA9B;AACAD,MAAAA,KAAK,CAACtJ,WAAN,GAAoBjI,MAAM,CAACkB,IAAP,CAAYqQ,KAAK,CAACtJ,WAAlB,EAA+B6B,MAA/B,CAAsC,UAAUC,GAAV,EAAeiH,OAAf,EAAwB;AAChF,YAAIS,CAAC,GAAGF,KAAK,CAACtJ,WAAN,CAAkB+I,OAAlB,CAAR;AACA,eAAOvP,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKsI,GAAL,CAAd,EAAyB,EAAzB,EAA6BnI,eAAe,CAAC,EAAD,EAAKoP,OAAL,EAAc;AAC5EL,UAAAA,aAAa,EAAEA,aAD6D;AAE5ElI,UAAAA,UAAU,EAAEA,UAFgE;AAG5ED,UAAAA,KAAK,EAAEiJ,CAAC,CAACjJ,KAHmE;AAI5EkJ,UAAAA,WAAW,EAAExB,cAAc,CAACpL,IAAD,EAAO2M,CAAC,CAACjJ,KAAT,EAAgB4H,UAAhB;AAJiD,SAAd,CAA5C,CAApB;AAMD,OARmB,EAQjBoB,uBARiB,CAApB;AASD;;AACD,WAAO/P,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKiG,MAAL,CAAd,EAA4B,EAA5B,EAAgC9F,eAAe,CAAC,EAAD,EAAKsP,MAAL,EAAaK,KAAb,CAA/C,CAApB;AACD,GAfM,EAeJD,2BAfI,CAAP;AAgBD,CAxDM;AA0DP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIK,eAAe,GAAG,SAASA,eAAT,CAAyBvE,KAAzB,EAAgCwE,IAAhC,EAAsC;AACjE,MAAIrE,aAAa,GAAGqE,IAAI,CAACrE,aAAzB;AAAA,MACExI,IAAI,GAAG6M,IAAI,CAAC7M,IADd;AAAA,MAEE+I,SAAS,GAAG8D,IAAI,CAAC9D,SAFnB;AAAA,MAGE+D,cAAc,GAAGD,IAAI,CAACC,cAHxB;AAAA,MAIEC,aAAa,GAAGF,IAAI,CAACE,aAJvB;AAKA,MAAIC,SAAS,GAAGxE,aAAa,IAAIqE,IAAI,CAACxE,KAAtC;;AACA,MAAI2E,SAAS,KAAK,MAAd,IAAwBA,SAAS,KAAK,QAA1C,EAAoD;AAClD,WAAO,IAAP;AACD;;AACD,MAAIjE,SAAS,IAAI/I,IAAI,KAAK,QAAtB,IAAkC8M,cAAlC,KAAqDA,cAAc,CAAC,CAAD,CAAd,KAAsB,MAAtB,IAAgCA,cAAc,CAAC,CAAD,CAAd,KAAsB,MAA3G,CAAJ,EAAwH;AACtH;AACA,QAAI1M,MAAM,GAAGiI,KAAK,CAACjI,MAAN,EAAb;;AACA,QAAI,CAACA,MAAM,CAACxE,MAAZ,EAAoB;AAClB,aAAO,IAAP;AACD;;AACD,QAAIqR,UAAU,GAAGnO,iBAAiB,CAACsB,MAAD,EAAS2I,SAAT,EAAoBgE,aAApB,CAAlC;AACA1E,IAAAA,KAAK,CAACjI,MAAN,CAAa,CAAChC,GAAG,CAAC6O,UAAD,CAAJ,EAAkB9O,GAAG,CAAC8O,UAAD,CAArB,CAAb;AACA,WAAO;AACLvE,MAAAA,SAAS,EAAEuE;AADN,KAAP;AAGD;;AACD,MAAIlE,SAAS,IAAI/I,IAAI,KAAK,QAA1B,EAAoC;AAClC,QAAIkN,OAAO,GAAG7E,KAAK,CAACjI,MAAN,EAAd;;AACA,QAAI+M,WAAW,GAAGpO,wBAAwB,CAACmO,OAAD,EAAUnE,SAAV,EAAqBgE,aAArB,CAA1C;;AACA,WAAO;AACLrE,MAAAA,SAAS,EAAEyE;AADN,KAAP;AAGD;;AACD,SAAO,IAAP;AACD,CA9BM;AA+BP,OAAO,SAASC,uBAAT,CAAiCC,KAAjC,EAAwC;AAC7C,MAAIrM,IAAI,GAAGqM,KAAK,CAACrM,IAAjB;AAAA,MACEH,KAAK,GAAGwM,KAAK,CAACxM,KADhB;AAAA,MAEEyD,QAAQ,GAAG+I,KAAK,CAAC/I,QAFnB;AAAA,MAGEnE,KAAK,GAAGkN,KAAK,CAAClN,KAHhB;AAAA,MAIEc,KAAK,GAAGoM,KAAK,CAACpM,KAJhB;AAAA,MAKErB,OAAO,GAAGyN,KAAK,CAACzN,OALlB;;AAMA,MAAIoB,IAAI,CAAChB,IAAL,KAAc,UAAlB,EAA8B;AAC5B;AACA;AACA,QAAI,CAACgB,IAAI,CAACsM,uBAAN,IAAiCtM,IAAI,CAACpB,OAAtC,IAAiD,CAACvB,KAAK,CAAC8B,KAAK,CAACa,IAAI,CAACpB,OAAN,CAAN,CAA3D,EAAkF;AAChF;AACA,UAAI2N,WAAW,GAAGtO,gBAAgB,CAAC4B,KAAD,EAAQ,OAAR,EAAiBV,KAAK,CAACa,IAAI,CAACpB,OAAN,CAAtB,CAAlC;;AACA,UAAI2N,WAAJ,EAAiB;AACf,eAAOA,WAAW,CAAC5M,UAAZ,GAAyB2D,QAAQ,GAAG,CAA3C;AACD;AACF;;AACD,WAAOzD,KAAK,CAACI,KAAD,CAAL,GAAeJ,KAAK,CAACI,KAAD,CAAL,CAAaN,UAAb,GAA0B2D,QAAQ,GAAG,CAApD,GAAwD,IAA/D;AACD;;AACD,MAAInH,KAAK,GAAGwC,iBAAiB,CAACQ,KAAD,EAAQ,CAAC9B,KAAK,CAACuB,OAAD,CAAN,GAAkBA,OAAlB,GAA4BoB,IAAI,CAACpB,OAAzC,CAA7B;AACA,SAAO,CAACvB,KAAK,CAAClB,KAAD,CAAN,GAAgB6D,IAAI,CAACqH,KAAL,CAAWlL,KAAX,CAAhB,GAAoC,IAA3C;AACD;AACD,OAAO,IAAIqQ,sBAAsB,GAAG,SAASA,sBAAT,CAAgCC,KAAhC,EAAuC;AACzE,MAAIzM,IAAI,GAAGyM,KAAK,CAACzM,IAAjB;AAAA,MACEH,KAAK,GAAG4M,KAAK,CAAC5M,KADhB;AAAA,MAEEoE,MAAM,GAAGwI,KAAK,CAACxI,MAFjB;AAAA,MAGEX,QAAQ,GAAGmJ,KAAK,CAACnJ,QAHnB;AAAA,MAIEnE,KAAK,GAAGsN,KAAK,CAACtN,KAJhB;AAAA,MAKEc,KAAK,GAAGwM,KAAK,CAACxM,KALhB;;AAMA,MAAID,IAAI,CAAChB,IAAL,KAAc,UAAlB,EAA8B;AAC5B,WAAOa,KAAK,CAACI,KAAD,CAAL,GAAeJ,KAAK,CAACI,KAAD,CAAL,CAAaN,UAAb,GAA0BsE,MAAzC,GAAkD,IAAzD;AACD;;AACD,MAAI9H,KAAK,GAAGwC,iBAAiB,CAACQ,KAAD,EAAQa,IAAI,CAACpB,OAAb,EAAsBoB,IAAI,CAACZ,MAAL,CAAYa,KAAZ,CAAtB,CAA7B;AACA,SAAO,CAAC5C,KAAK,CAAClB,KAAD,CAAN,GAAgB6D,IAAI,CAACqH,KAAL,CAAWlL,KAAX,IAAoBmH,QAAQ,GAAG,CAA/B,GAAmCW,MAAnD,GAA4D,IAAnE;AACD,CAZM;AAaP,OAAO,IAAIyI,iBAAiB,GAAG,SAASA,iBAAT,CAA2BC,KAA3B,EAAkC;AAC/D,MAAIC,WAAW,GAAGD,KAAK,CAACC,WAAxB;AACA,MAAIxN,MAAM,GAAGwN,WAAW,CAACvF,KAAZ,CAAkBjI,MAAlB,EAAb;;AACA,MAAIwN,WAAW,CAAC5N,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,QAAI8B,QAAQ,GAAGX,IAAI,CAAC/C,GAAL,CAASgC,MAAM,CAAC,CAAD,CAAf,EAAoBA,MAAM,CAAC,CAAD,CAA1B,CAAf;AACA,QAAI2B,QAAQ,GAAGZ,IAAI,CAAChD,GAAL,CAASiC,MAAM,CAAC,CAAD,CAAf,EAAoBA,MAAM,CAAC,CAAD,CAA1B,CAAf;;AACA,QAAI0B,QAAQ,IAAI,CAAZ,IAAiBC,QAAQ,IAAI,CAAjC,EAAoC;AAClC,aAAO,CAAP;AACD;;AACD,QAAIA,QAAQ,GAAG,CAAf,EAAkB;AAChB,aAAOA,QAAP;AACD;;AACD,WAAOD,QAAP;AACD;;AACD,SAAO1B,MAAM,CAAC,CAAD,CAAb;AACD,CAfM;AAgBP,OAAO,IAAIyN,oBAAoB,GAAG,SAASA,oBAAT,CAA8B3L,IAA9B,EAAoCgB,WAApC,EAAiD;AACjF,MAAI4K,WAAJ;;AACA,MAAIxL,cAAc,GAAG,CAACwL,WAAW,GAAG5L,IAAI,CAAClC,IAApB,MAA8B,IAA9B,IAAsC8N,WAAW,KAAK,KAAK,CAA3D,IAAgEA,WAAW,CAACvL,YAA5E,GAA2F7F,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKwF,IAAI,CAAClC,IAAL,CAAUuC,YAAf,CAAd,EAA4CL,IAAI,CAACM,KAAjD,CAAxG,GAAkKN,IAAI,CAACM,KAA5L;AACA,MAAIyJ,OAAO,GAAG3J,cAAc,CAAC2J,OAA7B;;AACA,MAAI7M,UAAU,CAAC6M,OAAD,CAAd,EAAyB;AACvB,QAAIO,KAAK,GAAGtJ,WAAW,CAAC+I,OAAD,CAAvB;;AACA,QAAIO,KAAJ,EAAW;AACT,UAAIuB,SAAS,GAAGvB,KAAK,CAAC/I,KAAN,CAAYG,OAAZ,CAAoB1B,IAApB,CAAhB;AACA,aAAO6L,SAAS,IAAI,CAAb,GAAiBvB,KAAK,CAACG,WAAN,CAAkBoB,SAAlB,CAAjB,GAAgD,IAAvD;AACD;AACF;;AACD,SAAO,IAAP;AACD,CAZM;;AAaP,IAAIC,iBAAiB,GAAG,SAASA,iBAAT,CAA2BjO,IAA3B,EAAiC;AACvD,SAAOA,IAAI,CAACgF,MAAL,CAAY,UAAUpC,MAAV,EAAkBxC,KAAlB,EAAyB;AAC1C,WAAO,CAAC/B,GAAG,CAAC+B,KAAK,CAACoF,MAAN,CAAa,CAAC5C,MAAM,CAAC,CAAD,CAAP,CAAb,EAA0BtG,MAA1B,CAAiC8C,QAAjC,CAAD,CAAJ,EAAkDhB,GAAG,CAACgC,KAAK,CAACoF,MAAN,CAAa,CAAC5C,MAAM,CAAC,CAAD,CAAP,CAAb,EAA0BtG,MAA1B,CAAiC8C,QAAjC,CAAD,CAArD,CAAP;AACD,GAFM,EAEJ,CAACmB,QAAD,EAAW,CAACA,QAAZ,CAFI,CAAP;AAGD,CAJD;;AAKA,OAAO,IAAI2N,sBAAsB,GAAG,SAASA,sBAAT,CAAgC/K,WAAhC,EAA6CgL,UAA7C,EAAyDC,QAAzD,EAAmE;AACrG,SAAOlT,MAAM,CAACkB,IAAP,CAAY+G,WAAZ,EAAyB6B,MAAzB,CAAgC,UAAUpC,MAAV,EAAkBsJ,OAAlB,EAA2B;AAChE,QAAIO,KAAK,GAAGtJ,WAAW,CAAC+I,OAAD,CAAvB;AACA,QAAIU,WAAW,GAAGH,KAAK,CAACG,WAAxB;AACA,QAAIvM,MAAM,GAAGuM,WAAW,CAAC5H,MAAZ,CAAmB,UAAUC,GAAV,EAAe7E,KAAf,EAAsB;AACpD,UAAIiO,CAAC,GAAGJ,iBAAiB,CAAC7N,KAAK,CAAC/E,KAAN,CAAY8S,UAAZ,EAAwBC,QAAQ,GAAG,CAAnC,CAAD,CAAzB;AACA,aAAO,CAAChN,IAAI,CAAC/C,GAAL,CAAS4G,GAAG,CAAC,CAAD,CAAZ,EAAiBoJ,CAAC,CAAC,CAAD,CAAlB,CAAD,EAAyBjN,IAAI,CAAChD,GAAL,CAAS6G,GAAG,CAAC,CAAD,CAAZ,EAAiBoJ,CAAC,CAAC,CAAD,CAAlB,CAAzB,CAAP;AACD,KAHY,EAGV,CAAC9N,QAAD,EAAW,CAACA,QAAZ,CAHU,CAAb;AAIA,WAAO,CAACa,IAAI,CAAC/C,GAAL,CAASgC,MAAM,CAAC,CAAD,CAAf,EAAoBuC,MAAM,CAAC,CAAD,CAA1B,CAAD,EAAiCxB,IAAI,CAAChD,GAAL,CAASiC,MAAM,CAAC,CAAD,CAAf,EAAoBuC,MAAM,CAAC,CAAD,CAA1B,CAAjC,CAAP;AACD,GARM,EAQJ,CAACrC,QAAD,EAAW,CAACA,QAAZ,CARI,EAQmBE,GARnB,CAQuB,UAAUmC,MAAV,EAAkB;AAC9C,WAAOA,MAAM,KAAKrC,QAAX,IAAuBqC,MAAM,KAAK,CAACrC,QAAnC,GAA8C,CAA9C,GAAkDqC,MAAzD;AACD,GAVM,CAAP;AAWD,CAZM;AAaP,OAAO,IAAI0L,aAAa,GAAG,iDAApB;AACP,OAAO,IAAIC,aAAa,GAAG,kDAApB;AACP,OAAO,IAAIC,oBAAoB,GAAG,SAASA,oBAAT,CAA8BC,eAA9B,EAA+CC,UAA/C,EAA2DC,iBAA3D,EAA8E;AAC9G,MAAIpQ,UAAU,CAACkQ,eAAD,CAAd,EAAiC;AAC/B,WAAOA,eAAe,CAACC,UAAD,EAAaC,iBAAb,CAAtB;AACD;;AACD,MAAI,CAACpT,KAAK,CAACI,OAAN,CAAc8S,eAAd,CAAL,EAAqC;AACnC,WAAOC,UAAP;AACD;;AACD,MAAIrO,MAAM,GAAG,EAAb;AAEA;;AACA,MAAIjB,QAAQ,CAACqP,eAAe,CAAC,CAAD,CAAhB,CAAZ,EAAkC;AAChCpO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYsO,iBAAiB,GAAGF,eAAe,CAAC,CAAD,CAAlB,GAAwBrN,IAAI,CAAC/C,GAAL,CAASoQ,eAAe,CAAC,CAAD,CAAxB,EAA6BC,UAAU,CAAC,CAAD,CAAvC,CAArD;AACD,GAFD,MAEO,IAAIJ,aAAa,CAAC7S,IAAd,CAAmBgT,eAAe,CAAC,CAAD,CAAlC,CAAJ,EAA4C;AACjD,QAAIrR,KAAK,GAAG,CAACkR,aAAa,CAACM,IAAd,CAAmBH,eAAe,CAAC,CAAD,CAAlC,EAAuC,CAAvC,CAAb;AACApO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYqO,UAAU,CAAC,CAAD,CAAV,GAAgBtR,KAA5B;AACD,GAHM,MAGA,IAAImB,UAAU,CAACkQ,eAAe,CAAC,CAAD,CAAhB,CAAd,EAAoC;AACzCpO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoO,eAAe,CAAC,CAAD,CAAf,CAAmBC,UAAU,CAAC,CAAD,CAA7B,CAAZ;AACD,GAFM,MAEA;AACLrO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYqO,UAAU,CAAC,CAAD,CAAtB;AACD;;AACD,MAAItP,QAAQ,CAACqP,eAAe,CAAC,CAAD,CAAhB,CAAZ,EAAkC;AAChCpO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYsO,iBAAiB,GAAGF,eAAe,CAAC,CAAD,CAAlB,GAAwBrN,IAAI,CAAChD,GAAL,CAASqQ,eAAe,CAAC,CAAD,CAAxB,EAA6BC,UAAU,CAAC,CAAD,CAAvC,CAArD;AACD,GAFD,MAEO,IAAIH,aAAa,CAAC9S,IAAd,CAAmBgT,eAAe,CAAC,CAAD,CAAlC,CAAJ,EAA4C;AACjD,QAAII,MAAM,GAAG,CAACN,aAAa,CAACK,IAAd,CAAmBH,eAAe,CAAC,CAAD,CAAlC,EAAuC,CAAvC,CAAd;;AACApO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYqO,UAAU,CAAC,CAAD,CAAV,GAAgBG,MAA5B;AACD,GAHM,MAGA,IAAItQ,UAAU,CAACkQ,eAAe,CAAC,CAAD,CAAhB,CAAd,EAAoC;AACzCpO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoO,eAAe,CAAC,CAAD,CAAf,CAAmBC,UAAU,CAAC,CAAD,CAA7B,CAAZ;AACD,GAFM,MAEA;AACLrO,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYqO,UAAU,CAAC,CAAD,CAAtB;AACD;AACD;;;AAEA,SAAOrO,MAAP;AACD,CAjCM;AAmCP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIyO,iBAAiB,GAAG,SAASA,iBAAT,CAA2B7N,IAA3B,EAAiCH,KAAjC,EAAwCiO,KAAxC,EAA+C;AAC5E;AACA,MAAI9N,IAAI,IAAIA,IAAI,CAACqH,KAAb,IAAsBrH,IAAI,CAACqH,KAAL,CAAWI,SAArC,EAAgD;AAC9C;AACA,QAAIsG,SAAS,GAAG/N,IAAI,CAACqH,KAAL,CAAWI,SAAX,EAAhB;;AACA,QAAI,CAACqG,KAAD,IAAUC,SAAS,GAAG,CAA1B,EAA6B;AAC3B,aAAOA,SAAP;AACD;AACF;;AACD,MAAI/N,IAAI,IAAIH,KAAR,IAAiBA,KAAK,CAACjF,MAAN,IAAgB,CAArC,EAAwC;AACtC,QAAIoT,YAAY,GAAGnQ,MAAM,CAACgC,KAAD,EAAQ,UAAU3G,CAAV,EAAa;AAC5C,aAAOA,CAAC,CAACyG,UAAT;AACD,KAFwB,CAAzB;AAGA,QAAI2D,QAAQ,GAAGhE,QAAf;;AACA,SAAK,IAAIzE,CAAC,GAAG,CAAR,EAAWF,GAAG,GAAGqT,YAAY,CAACpT,MAAnC,EAA2CC,CAAC,GAAGF,GAA/C,EAAoDE,CAAC,EAArD,EAAyD;AACvD,UAAI0F,GAAG,GAAGyN,YAAY,CAACnT,CAAD,CAAtB;AACA,UAAIqJ,IAAI,GAAG8J,YAAY,CAACnT,CAAC,GAAG,CAAL,CAAvB;AACAyI,MAAAA,QAAQ,GAAGnD,IAAI,CAAC/C,GAAL,CAAS,CAACmD,GAAG,CAACZ,UAAJ,IAAkB,CAAnB,KAAyBuE,IAAI,CAACvE,UAAL,IAAmB,CAA5C,CAAT,EAAyD2D,QAAzD,CAAX;AACD;;AACD,WAAOA,QAAQ,KAAKhE,QAAb,GAAwB,CAAxB,GAA4BgE,QAAnC;AACD;;AACD,SAAOwK,KAAK,GAAGhO,SAAH,GAAe,CAA3B;AACD,CAtBM;AAuBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAImO,yBAAyB,GAAG,SAASA,yBAAT,CAAmCT,eAAnC,EAAoDU,gBAApD,EAAsEC,SAAtE,EAAiF;AACtH,MAAI,CAACX,eAAD,IAAoB,CAACA,eAAe,CAAC5S,MAAzC,EAAiD;AAC/C,WAAOsT,gBAAP;AACD;;AACD,MAAItQ,OAAO,CAAC4P,eAAD,EAAkBhQ,GAAG,CAAC2Q,SAAD,EAAY,0BAAZ,CAArB,CAAX,EAA0E;AACxE,WAAOD,gBAAP;AACD;;AACD,SAAOV,eAAP;AACD,CARM;AASP,OAAO,IAAIY,cAAc,GAAG,SAASA,cAAT,CAAwBC,aAAxB,EAAuCC,OAAvC,EAAgD;AAC1E,MAAIhN,cAAc,GAAG+M,aAAa,CAACrP,IAAd,CAAmBuC,YAAnB,GAAkC7F,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK2S,aAAa,CAACrP,IAAd,CAAmBuC,YAAxB,CAAd,EAAqD8M,aAAa,CAAC7M,KAAnE,CAA/C,GAA2H6M,aAAa,CAAC7M,KAA9J;AACA,MAAI5C,OAAO,GAAG0C,cAAc,CAAC1C,OAA7B;AAAA,MACEvE,IAAI,GAAGiH,cAAc,CAACjH,IADxB;AAAA,MAEEkU,IAAI,GAAGjN,cAAc,CAACiN,IAFxB;AAAA,MAGEC,SAAS,GAAGlN,cAAc,CAACkN,SAH7B;AAAA,MAIEC,WAAW,GAAGnN,cAAc,CAACmN,WAJ/B;AAAA,MAKE/F,SAAS,GAAGpH,cAAc,CAACoH,SAL7B;AAAA,MAMEwC,IAAI,GAAG5J,cAAc,CAAC4J,IANxB;AAOA,SAAOxP,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK6C,WAAW,CAAC8P,aAAD,EAAgB,KAAhB,CAAhB,CAAd,EAAuD,EAAvD,EAA2D;AAC7EzP,IAAAA,OAAO,EAAEA,OADoE;AAE7E2P,IAAAA,IAAI,EAAEA,IAFuE;AAG7EC,IAAAA,SAAS,EAAEA,SAHkE;AAI7EnU,IAAAA,IAAI,EAAEA,IAAI,IAAIuE,OAJ+D;AAK7E8P,IAAAA,KAAK,EAAEzN,yBAAyB,CAACoN,aAAD,CAL6C;AAM7ElS,IAAAA,KAAK,EAAEwC,iBAAiB,CAAC2P,OAAD,EAAU1P,OAAV,CANqD;AAO7EI,IAAAA,IAAI,EAAEyP,WAPuE;AAQ7EH,IAAAA,OAAO,EAAEA,OARoE;AAS7E5F,IAAAA,SAAS,EAAEA,SATkE;AAU7EwC,IAAAA,IAAI,EAAEA;AAVuE,GAA3D,CAApB;AAYD,CArBM","sourcesContent":["function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport max from 'lodash/max';\nimport min from 'lodash/min';\nimport isNil from 'lodash/isNil';\nimport isFunction from 'lodash/isFunction';\nimport isString from 'lodash/isString';\nimport get from 'lodash/get';\nimport flatMap from 'lodash/flatMap';\nimport isNan from 'lodash/isNaN';\nimport upperFirst from 'lodash/upperFirst';\nimport isEqual from 'lodash/isEqual';\nimport sortBy from 'lodash/sortBy';\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport { ErrorBar } from '../cartesian/ErrorBar';\nimport { findEntryInArray, getPercentValue, isNumber, isNumOrStr, mathSign, uniqueId } from './DataUtils';\nimport { filterProps, findAllByType, getDisplayName } from './ReactUtils';\n// TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nimport { getLegendProps } from './getLegendProps';\n\n// Exported for backwards compatibility\nexport { getLegendProps };\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNil(obj) || isNil(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\n/**\n * Get domain of data by key.\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n  if (type === 'number') {\n    // @ts-expect-error parseFloat type only accepts strings\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [min(domain), max(domain)] : [Infinity, -Infinity];\n  }\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !isNil(entry);\n  }) : flattenData;\n\n  // Supports x-axis of Date type\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n\n  // if there are 1 or less ticks ticks then the active tick is at index 0\n  if (len <= 1) {\n    return 0;\n  }\n  if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n    var range = axis.range;\n    // ticks are distributed in a circle\n    for (var i = 0; i < len; i++) {\n      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n      var cur = unsortedTicks[i].coordinate;\n      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n      var sameDirectionCoord = void 0;\n      if (mathSign(cur - before) !== mathSign(after - cur)) {\n        var diffInterval = [];\n        if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n          sameDirectionCoord = after;\n          var curInRange = cur + range[1] - range[0];\n          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n        } else {\n          sameDirectionCoord = before;\n          var afterInRange = after + range[1] - range[0];\n          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n        }\n        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      } else {\n        var minValue = Math.min(before, after);\n        var maxValue = Math.max(before, after);\n        if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    // ticks are distributed in a single direction\n    for (var _i = 0; _i < len; _i++) {\n      if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n        index = ticks[_i].index;\n        break;\n      }\n    }\n  }\n  return index;\n};\n\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _item$type;\n  var _ref = item,\n    displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n  var defaultedProps = (_item$type = item.type) !== null && _item$type !== void 0 && _item$type.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n  var stroke = defaultedProps.stroke,\n    fill = defaultedProps.fill;\n  var result;\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n    default:\n      result = fill;\n      break;\n  }\n  return result;\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\nexport var getBarSizeList = function getBarSizeList(_ref2) {\n  var globalSize = _ref2.barSize,\n    totalSize = _ref2.totalSize,\n    _ref2$stackGroups = _ref2.stackGroups,\n    stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;\n  if (!stackGroups) {\n    return {};\n  }\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n        items = _sgs$stackIds$j.items,\n        cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n      if (barItems && barItems.length) {\n        var barItemDefaultProps = barItems[0].type.defaultProps;\n        var barItemProps = barItemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, barItemDefaultProps), barItems[0].props) : barItems[0].props;\n        var selfSize = barItemProps.barSize;\n        var cateId = barItemProps[cateAxisId];\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n        var barSize = isNil(selfSize) ? globalSize : selfSize;\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: isNil(barSize) ? undefined : getPercentValue(barSize, totalSize, 0)\n        });\n      }\n    }\n  }\n  return result;\n};\n/**\n * Calculate the size of each bar and offset between start of band and the bar\n *\n * @param  {number} bandSize is the size of area where bars can render\n * @param  {number | string} barGap is the gap size, as a percentage of `bandSize`.\n *                                  Can be defined as number or percent string\n * @param  {number | string} barCategoryGap is the gap size, as a percentage of `bandSize`.\n *                                  Can be defined as number or percent string\n * @param  {Array<object>} sizeList Sizes of all groups\n * @param  {number} maxBarSize The maximum size of each bar\n * @return {Array<object>} The size and offset of each bar\n */\nexport var getBarPosition = function getBarPosition(_ref3) {\n  var barGap = _ref3.barGap,\n    barCategoryGap = _ref3.barCategoryGap,\n    bandSize = _ref3.bandSize,\n    _ref3$sizeList = _ref3.sizeList,\n    sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList,\n    maxBarSize = _ref3.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result;\n  var initialValue = [];\n\n  // whether or not is barSize setted by user\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    // @ts-expect-error the type check above does not check for type number explicitly\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newPosition = {\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          // @ts-expect-error the type check above does not check for type number explicitly\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      };\n      var newRes = [].concat(_toConsumableArray(res), [newPosition]);\n      prev = newRes[newRes.length - 1].position;\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n      return newRes;\n    }, initialValue);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n      return newRes;\n    }, initialValue);\n  }\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, _unused, props, legendBox) {\n  var children = props.children,\n    width = props.width,\n    margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n  if (legendProps) {\n    var _ref4 = legendBox || {},\n      boxWidth = _ref4.width,\n      boxHeight = _ref4.height;\n    var align = legendProps.align,\n      verticalAlign = legendProps.verticalAlign,\n      layout = legendProps.layout;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, offset[align] + (boxWidth || 0)));\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, offset[verticalAlign] + (boxHeight || 0)));\n    }\n  }\n  return offset;\n};\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n  if (isNil(axisType)) {\n    return true;\n  }\n  if (layout === 'horizontal') {\n    return axisType === 'yAxis';\n  }\n  if (layout === 'vertical') {\n    return axisType === 'xAxis';\n  }\n  if (direction === 'x') {\n    return axisType === 'xAxis';\n  }\n  if (direction === 'y') {\n    return axisType === 'yAxis';\n  }\n  return true;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n  });\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey);\n      if (isNil(entryValue)) return result;\n      var mainValue = Array.isArray(entryValue) ? [min(entryValue), max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n  }).filter(function (entry) {\n    return !isNil(entry);\n  });\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\n\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {LayoutType} layout The type of layout\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(\n    // @ts-expect-error if (type === number) means that the domain is numerical type\n    // - but this link is missing in the type definition\n    function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  var tag = {};\n  // Get the union set of category axis\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      // @ts-expect-error Date cannot index an object\n      if (!tag[entry[i]]) {\n        // @ts-expect-error Date cannot index an object\n        tag[entry[i]] = true;\n\n        // @ts-expect-error Date cannot index an object\n        result.push(entry[i]);\n      }\n    }\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimun value of axis\n * @param {Number} maxValue        The maximun value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, minValue, maxValue, syncWithTicks) {\n  if (syncWithTicks) {\n    return ticks.map(function (entry) {\n      return entry.coordinate;\n    });\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n    type = axis.type,\n    range = axis.range;\n  var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axis.axisType === 'angleAxis' && (range === null || range === void 0 ? void 0 : range.length) >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    var result = (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n    return result.filter(function (row) {\n      return !isNan(row.coordinate);\n    });\n  }\n\n  // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} childHandler Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nvar handlerWeakMap = new WeakMap();\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, childHandler) {\n  if (typeof childHandler !== 'function') {\n    return defaultHandler;\n  }\n  if (!handlerWeakMap.has(defaultHandler)) {\n    handlerWeakMap.set(defaultHandler, new WeakMap());\n  }\n  var childWeakMap = handlerWeakMap.get(defaultHandler);\n  if (childWeakMap.has(childHandler)) {\n    return childWeakMap.get(childHandler);\n  }\n  var combineHandler = function combineHandler() {\n    defaultHandler.apply(void 0, arguments);\n    childHandler.apply(void 0, arguments);\n  };\n  childWeakMap.set(childHandler, combineHandler);\n  return combineHandler;\n};\n\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @param  {Boolean}  hasBar        if it has a bar\n * @return {object}               The scale function and resolved name\n */\nexport var parseScale = function parseScale(axis, chartType, hasBar) {\n  var scale = axis.scale,\n    type = axis.type,\n    layout = axis.layout,\n    axisType = axis.axisType;\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n  if (isString(scale)) {\n    var name = \"scale\".concat(upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n  return isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n  return null;\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param {Array} value input that will be truncated\n * @param {Array} domain boundaries\n * @returns {Array} tuple of two numbers\n */\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n  var stack = shapeStack()\n  // @ts-expect-error stack.keys type wants an array of strings, but we provide array of DataKeys\n  .keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  }\n\n  // reversing items to affect render order (for layering)\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var parentStackGroupsInitialValue = {};\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$type2;\n    var defaultedProps = (_item$type2 = item.type) !== null && _item$type2 !== void 0 && _item$type2.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var stackId = defaultedProps.stackId,\n      hide = defaultedProps.hide;\n    if (hide) {\n      return result;\n    }\n    var axisId = defaultedProps[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, parentStackGroupsInitialValue);\n  var axisStackGroupsInitialValue = {};\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n    if (group.hasStack) {\n      var stackGroupsInitialValue = {};\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, stackGroupsInitialValue);\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, axisStackGroupsInitialValue);\n};\n\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n    type = opts.type,\n    tickCount = opts.tickCount,\n    originalDomain = opts.originalDomain,\n    allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    if (!domain.length) {\n      return null;\n    }\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain([min(tickValues), max(tickValues)]);\n    return {\n      niceTicks: tickValues\n    };\n  }\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n    return {\n      niceTicks: _tickValues\n    };\n  }\n  return null;\n};\nexport function getCateCoordinateOfLine(_ref5) {\n  var axis = _ref5.axis,\n    ticks = _ref5.ticks,\n    bandSize = _ref5.bandSize,\n    entry = _ref5.entry,\n    index = _ref5.index,\n    dataKey = _ref5.dataKey;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNil(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNil(dataKey) ? dataKey : axis.dataKey);\n  return !isNil(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref6) {\n  var axis = _ref6.axis,\n    ticks = _ref6.ticks,\n    offset = _ref6.offset,\n    bandSize = _ref6.bandSize,\n    entry = _ref6.entry,\n    index = _ref6.index;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref7) {\n  var numericAxis = _ref7.numericAxis;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var minValue = Math.min(domain[0], domain[1]);\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var _item$type3;\n  var defaultedProps = (_item$type3 = item.type) !== null && _item$type3 !== void 0 && _item$type3.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n  var stackId = defaultedProps.stackId;\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n    if (group) {\n      var itemIndex = group.items.indexOf(item);\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n  return null;\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [min(entry.concat([result[0]]).filter(isNumber)), max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (isFunction(specifiedDomain)) {\n    return specifiedDomain(dataDomain, allowDataOverflow);\n  }\n  if (!Array.isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n  var domain = [];\n\n  /* eslint-disable prefer-destructuring */\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n    domain[1] = dataDomain[1] + _value;\n  } else if (isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n  return domain;\n};\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  // @ts-expect-error we need to rethink scale type\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    // @ts-expect-error we need to rethink scale type\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis ReactElement\n * @returns {Array}        domains\n */\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n  if (isEqual(specifiedDomain, get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n  return specifiedDomain;\n};\nexport var getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n  var defaultedProps = graphicalItem.type.defaultProps ? _objectSpread(_objectSpread({}, graphicalItem.type.defaultProps), graphicalItem.props) : graphicalItem.props;\n  var dataKey = defaultedProps.dataKey,\n    name = defaultedProps.name,\n    unit = defaultedProps.unit,\n    formatter = defaultedProps.formatter,\n    tooltipType = defaultedProps.tooltipType,\n    chartType = defaultedProps.chartType,\n    hide = defaultedProps.hide;\n  return _objectSpread(_objectSpread({}, filterProps(graphicalItem, false)), {}, {\n    dataKey: dataKey,\n    unit: unit,\n    formatter: formatter,\n    name: name || dataKey,\n    color: getMainColorOfGraphicItem(graphicalItem),\n    value: getValueByDataKey(payload, dataKey),\n    type: tooltipType,\n    payload: payload,\n    chartType: chartType,\n    hide: hide\n  });\n};"]},"metadata":{},"sourceType":"module"}